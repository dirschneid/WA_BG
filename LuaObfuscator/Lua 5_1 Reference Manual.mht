From: =?windows-1251?B?0e718ODt5e3uIFdpbmRvd3MgSW50ZXJuZXQgRXhwbG9yZXIgOA==?=
Subject: Lua 5.1 Reference Manual
Date: Fri, 14 Oct 2011 12:18:54 +0400
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01CC8A6B.70EB3BE0"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7601.17514

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01CC8A6B.70EB3BE0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.lua.org/manual/5.1/manual.html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Lua 5.1 Reference Manual</TITLE><LINK =
rel=3Dstylesheet=20
type=3Dtext/css href=3D"http://www.lua.org/lua.css"><LINK =
rel=3Dstylesheet=20
type=3Dtext/css href=3D"http://www.lua.org/manual/manual.css">
<META content=3D"text/html; charset=3Diso-8859-1" =
http-equiv=3Dcontent-type>
<META name=3DGENERATOR content=3D"MSHTML 8.00.7601.17514"></HEAD>
<BODY>
<HR>

<H1><A href=3D"http://www.lua.org/home.html"><IMG border=3D0 alt=3D""=20
src=3D"http://www.lua.org/images/logo.gif"></A> Lua 5.1 Reference Manual =
</H1>by=20
Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes=20
<P><SMALL>Copyright =A9 2006=962008 Lua.org, PUC-Rio. Freely available =
under the=20
terms of the <A href=3D"http://www.lua.org/license.html">Lua =
license</A>. </SMALL>
<HR>

<P><A =
href=3D"http://www.lua.org/manual/5.1/index.html#contents">contents</A> =
=B7 <A=20
href=3D"http://www.lua.org/manual/5.1/index.html#index">index</A> =B7 <A =

href=3D"http://www.lua.org/manual/5.1/">english</A> =B7 <A=20
href=3D"http://www.lua.org/manual/5.1/pt/">portugu=EAs</A> =B7 <A=20
href=3D"http://www.lua.org/manual/5.1/es/">espa=F1ol</A> <!-- =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D --><!-- =
$Id: manual.of,v 1.48 2008/08/18 15:24:20 roberto Exp $ -->
<H1>1 - <A name=3D1>Introduction</A></H1>
<P>Lua is an extension programming language designed to support general=20
procedural programming with data description facilities. It also offers =
good=20
support for object-oriented programming, functional programming, and =
data-driven=20
programming. Lua is intended to be used as a powerful, light-weight =
scripting=20
language for any program that needs one. Lua is implemented as a =
library,=20
written in <EM>clean</EM> C (that is, in the common subset of =
ANSI&nbsp;C and=20
C++).=20
<P>Being an extension language, Lua has no notion of a "main" program: =
it only=20
works <EM>embedded</EM> in a host client, called the <EM>embedding =
program</EM>=20
or simply the <EM>host</EM>. This host program can invoke functions to =
execute a=20
piece of Lua code, can write and read Lua variables, and can register=20
C&nbsp;functions to be called by Lua code. Through the use of =
C&nbsp;functions,=20
Lua can be augmented to cope with a wide range of different domains, =
thus=20
creating customized programming languages sharing a syntactical =
framework. The=20
Lua distribution includes a sample host program called <CODE>lua</CODE>, =
which=20
uses the Lua library to offer a complete, stand-alone Lua interpreter.=20
<P>Lua is free software, and is provided as usual with no guarantees, as =
stated=20
in its license. The implementation described in this manual is available =
at=20
Lua's official web site, <CODE>www.lua.org</CODE>.=20
<P>Like any other reference manual, this document is dry in places. For =
a=20
discussion of the decisions behind the design of Lua, see the technical =
papers=20
available at Lua's web site. For a detailed introduction to programming =
in Lua,=20
see Roberto's book, <EM>Programming in Lua (Second Edition)</EM>.=20
<H1>2 - <A name=3D2>The Language</A></H1>
<P>This section describes the lexis, the syntax, and the semantics of =
Lua. In=20
other words, this section describes which tokens are valid, how they can =
be=20
combined, and what their combinations mean.=20
<P>The language constructs will be explained using the usual extended =
BNF=20
notation, in which {<EM>a</EM>}&nbsp;means&nbsp;0 or more <EM>a</EM>'s, =
and=20
[<EM>a</EM>]&nbsp;means an optional <EM>a</EM>. Non-terminals are shown =
like=20
non-terminal, keywords are shown like <B>kword</B>, and other terminal =
symbols=20
are shown like `<B>=3D</B>=B4. The complete syntax of Lua can be found =
in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#8">=A78</A> at the end =
of this=20
manual.=20
<H2>2.1 - <A name=3D2.1>Lexical Conventions</A></H2>
<P><EM>Names</EM> (also called <EM>identifiers</EM>) in Lua can be any =
string of=20
letters, digits, and underscores, not beginning with a digit. This =
coincides=20
with the definition of names in most languages. (The definition of =
letter=20
depends on the current locale: any character considered alphabetic by =
the=20
current locale can be used in an identifier.) Identifiers are used to =
name=20
variables and table fields.=20
<P>The following <EM>keywords</EM> are reserved and cannot be used as =
names: <PRE>     and       break     do        else      elseif
     end       false     for       function  if
     in        local     nil       not       or
     repeat    return    then      true      until     while
</PRE>
<P>Lua is a case-sensitive language: <CODE>and</CODE> is a reserved =
word, but=20
<CODE>And</CODE> and <CODE>AND</CODE> are two different, valid names. As =
a=20
convention, names starting with an underscore followed by uppercase =
letters=20
(such as <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-_VERSION"><CODE>_VE=
RSION</CODE></A>)=20
are reserved for internal global variables used by Lua.=20
<P>The following strings denote other tokens: <PRE>     +     -     *    =
 /     %     ^     #
     =3D=3D    ~=3D    &lt;=3D    &gt;=3D    &lt;     &gt;     =3D
     (     )     {     }     [     ]
     ;     :     ,     .     ..    ...
</PRE>
<P><EM>Literal strings</EM> can be delimited by matching single or =
double=20
quotes, and can contain the following C-like escape sequences: =
'<CODE>\a</CODE>'=20
(bell), '<CODE>\b</CODE>' (backspace), '<CODE>\f</CODE>' (form feed),=20
'<CODE>\n</CODE>' (newline), '<CODE>\r</CODE>' (carriage return),=20
'<CODE>\t</CODE>' (horizontal tab), '<CODE>\v</CODE>' (vertical tab),=20
'<CODE>\\</CODE>' (backslash), '<CODE>\"</CODE>' (quotation mark [double =

quote]), and '<CODE>\'</CODE>' (apostrophe [single quote]). Moreover, a=20
backslash followed by a real newline results in a newline in the string. =
A=20
character in a string can also be specified by its numerical value using =
the=20
escape sequence <CODE>\<EM>ddd</EM></CODE>, where <EM>ddd</EM> is a =
sequence of=20
up to three decimal digits. (Note that if a numerical escape is to be =
followed=20
by a digit, it must be expressed using exactly three digits.) Strings in =
Lua can=20
contain any 8-bit value, including embedded zeros, which can be =
specified as=20
'<CODE>\0</CODE>'.=20
<P>Literal strings can also be defined using a long format enclosed by =
<EM>long=20
brackets</EM>. We define an <EM>opening long bracket of level =
<EM>n</EM></EM> as=20
an opening square bracket followed by <EM>n</EM> equal signs followed by =
another=20
opening square bracket. So, an opening long bracket of level&nbsp;0 is =
written=20
as <CODE>[[</CODE>, an opening long bracket of level&nbsp;1 is written =
as=20
<CODE>[=3D[</CODE>, and so on. A <EM>closing long bracket</EM> is =
defined=20
similarly; for instance, a closing long bracket of level&nbsp;4 is =
written as=20
<CODE>]=3D=3D=3D=3D]</CODE>. A long string starts with an opening long =
bracket of any=20
level and ends at the first closing long bracket of the same level. =
Literals in=20
this bracketed form can run for several lines, do not interpret any =
escape=20
sequences, and ignore long brackets of any other level. They can contain =

anything except a closing bracket of the proper level.=20
<P>For convenience, when the opening long bracket is immediately =
followed by a=20
newline, the newline is not included in the string. As an example, in a =
system=20
using ASCII (in which '<CODE>a</CODE>' is coded as&nbsp;97, newline is =
coded=20
as&nbsp;10, and '<CODE>1</CODE>' is coded as&nbsp;49), the five literal =
strings=20
below denote the same string: <PRE>     a =3D 'alo\n123"'
     a =3D "alo\n123\""
     a =3D '\97lo\10\04923"'
     a =3D [[alo
     123"]]
     a =3D [=3D=3D[
     alo
     123"]=3D=3D]
</PRE>
<P>A <EM>numerical constant</EM> can be written with an optional decimal =
part=20
and an optional decimal exponent. Lua also accepts integer hexadecimal=20
constants, by prefixing them with <CODE>0x</CODE>. Examples of valid =
numerical=20
constants are <PRE>     3   3.0   3.1416   314.16e-2   0.31416E1   0xff  =
 0x56
</PRE>
<P>A <EM>comment</EM> starts with a double hyphen (<CODE>--</CODE>) =
anywhere=20
outside a string. If the text immediately after <CODE>--</CODE> is not =
an=20
opening long bracket, the comment is a <EM>short comment</EM>, which =
runs until=20
the end of the line. Otherwise, it is a <EM>long comment</EM>, which =
runs until=20
the corresponding closing long bracket. Long comments are frequently =
used to=20
disable code temporarily.=20
<H2>2.2 - <A name=3D2.2>Values and Types</A></H2>
<P>Lua is a <EM>dynamically typed language</EM>. This means that =
variables do=20
not have types; only values do. There are no type definitions in the =
language.=20
All values carry their own type.=20
<P>All values in Lua are <EM>first-class values</EM>. This means that =
all values=20
can be stored in variables, passed as arguments to other functions, and =
returned=20
as results.=20
<P>There are eight basic types in Lua: <EM>nil</EM>, <EM>boolean</EM>,=20
<EM>number</EM>, <EM>string</EM>, <EM>function</EM>, <EM>userdata</EM>,=20
<EM>thread</EM>, and <EM>table</EM>. <EM>Nil</EM> is the type of the =
value=20
<B>nil</B>, whose main property is to be different from any other value; =
it=20
usually represents the absence of a useful value. <EM>Boolean</EM> is =
the type=20
of the values <B>false</B> and <B>true</B>. Both <B>nil</B> and =
<B>false</B>=20
make a condition false; any other value makes it true. <EM>Number</EM>=20
represents real (double-precision floating-point) numbers. (It is easy =
to build=20
Lua interpreters that use other internal representations for numbers, =
such as=20
single-precision float or long integers; see file =
<CODE>luaconf.h</CODE>.)=20
<EM>String</EM> represents arrays of characters. Lua is 8-bit clean: =
strings can=20
contain any 8-bit character, including embedded zeros =
('<CODE>\0</CODE>') (see=20
<A href=3D"http://www.lua.org/manual/5.1/manual.html#2.1">=A72.1</A>).=20
<P>Lua can call (and manipulate) functions written in Lua and functions =
written=20
in C (see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.8">=A72.5.8</A>).=20

<P>The type <EM>userdata</EM> is provided to allow arbitrary C&nbsp;data =
to be=20
stored in Lua variables. This type corresponds to a block of raw memory =
and has=20
no pre-defined operations in Lua, except assignment and identity test. =
However,=20
by using <EM>metatables</EM>, the programmer can define operations for =
userdata=20
values (see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
Userdata values cannot be created or modified in Lua, only through the=20
C&nbsp;API. This guarantees the integrity of data owned by the host =
program.=20
<P>The type <EM>thread</EM> represents independent threads of execution =
and it=20
is used to implement coroutines (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.11">=A72.11</A>). Do =
not confuse=20
Lua threads with operating-system threads. Lua supports coroutines on =
all=20
systems, even those that do not support threads.=20
<P>The type <EM>table</EM> implements associative arrays, that is, =
arrays that=20
can be indexed not only with numbers, but with any value (except =
<B>nil</B>).=20
Tables can be <EM>heterogeneous</EM>; that is, they can contain values =
of all=20
types (except <B>nil</B>). Tables are the sole data structuring =
mechanism in=20
Lua; they can be used to represent ordinary arrays, symbol tables, sets, =

records, graphs, trees, etc. To represent records, Lua uses the field =
name as an=20
index. The language supports this representation by providing=20
<CODE>a.name</CODE> as syntactic sugar for <CODE>a["name"]</CODE>. There =
are=20
several convenient ways to create tables in Lua (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.7">=A72.5.7</A>).=20
<P>Like indices, the value of a table field can be of any type (except=20
<B>nil</B>). In particular, because functions are first-class values, =
table=20
fields can contain functions. Thus tables can also carry =
<EM>methods</EM> (see=20
<A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.9">=A72.5.9</A>).=20
<P>Tables, functions, threads, and (full) userdata values are =
<EM>objects</EM>:=20
variables do not actually <EM>contain</EM> these values, only=20
<EM>references</EM> to them. Assignment, parameter passing, and function =
returns=20
always manipulate references to such values; these operations do not =
imply any=20
kind of copy.=20
<P>The library function <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-type"><CODE>type</C=
ODE></A>=20
returns a string describing the type of a given value.=20
<H3>2.2.1 - <A name=3D2.2.1>Coercion</A></H3>
<P>Lua provides automatic conversion between string and number values at =
run=20
time. Any arithmetic operation applied to a string tries to convert this =
string=20
to a number, following the usual conversion rules. Conversely, whenever =
a number=20
is used where a string is expected, the number is converted to a string, =
in a=20
reasonable format. For complete control over how numbers are converted =
to=20
strings, use the <CODE>format</CODE> function from the string library =
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-string.format"><COD=
E>string.format</CODE></A>).=20

<H2>2.3 - <A name=3D2.3>Variables</A></H2>
<P>Variables are places that store values. There are three kinds of =
variables in=20
Lua: global variables, local variables, and table fields.=20
<P>A single name can denote a global variable or a local variable (or a=20
function's formal parameter, which is a particular kind of local =
variable): <PRE>	var ::=3D Name
</PRE>
<P>Name denotes identifiers, as defined in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.1">=A72.1</A>.=20
<P>Any variable is assumed to be global unless explicitly declared as a =
local=20
(see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.7">=A72.4.7</A>).=20
Local variables are <EM>lexically scoped</EM>: local variables can be =
freely=20
accessed by functions defined inside their scope (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.6">=A72.6</A>).=20
<P>Before the first assignment to a variable, its value is <B>nil</B>.=20
<P>Square brackets are used to index a table: <PRE>	var ::=3D prefixexp =
`<B>[</B>=B4 exp `<B>]</B>=B4
</PRE>
<P>The meaning of accesses to global variables and table fields can be =
changed=20
via metatables. An access to an indexed variable <CODE>t[i]</CODE> is =
equivalent=20
to a call <CODE>gettable_event(t,i)</CODE>. (See <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A> for a =
complete=20
description of the <CODE>gettable_event</CODE> function. This function =
is not=20
defined or callable in Lua. We use it here only for explanatory =
purposes.)=20
<P>The syntax <CODE>var.Name</CODE> is just syntactic sugar for=20
<CODE>var["Name"]</CODE>: <PRE>	var ::=3D prefixexp `<B>.</B>=B4 Name
</PRE>
<P>All global variables live as fields in ordinary Lua tables, called=20
<EM>environment tables</EM> or simply <EM>environments</EM> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.9">=A72.9</A>). Each =
function=20
has its own reference to an environment, so that all global variables in =
this=20
function will refer to this environment table. When a function is =
created, it=20
inherits the environment from the function that created it. To get the=20
environment table of a Lua function, you call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-getfenv"><CODE>getf=
env</CODE></A>.=20
To replace it, you call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-setfenv"><CODE>setf=
env</CODE></A>.=20
(You can only manipulate the environment of C&nbsp;functions through the =
debug=20
library; (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#5.9">=A75.9</A>).)=20
<P>An access to a global variable <CODE>x</CODE> is equivalent to=20
<CODE>_env.x</CODE>, which in turn is equivalent to <PRE>     =
gettable_event(_env, "x")
</PRE>
<P>where <CODE>_env</CODE> is the environment of the running function. =
(See <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A> for a =
complete=20
description of the <CODE>gettable_event</CODE> function. This function =
is not=20
defined or callable in Lua. Similarly, the <CODE>_env</CODE> variable is =
not=20
defined in Lua. We use them here only for explanatory purposes.)=20
<H2>2.4 - <A name=3D2.4>Statements</A></H2>
<P>Lua supports an almost conventional set of statements, similar to =
those in=20
Pascal or C. This set includes assignments, control structures, function =
calls,=20
and variable declarations.=20
<H3>2.4.1 - <A name=3D2.4.1>Chunks</A></H3>
<P>The unit of execution of Lua is called a <EM>chunk</EM>. A chunk is =
simply a=20
sequence of statements, which are executed sequentially. Each statement =
can be=20
optionally followed by a semicolon: <PRE>	chunk ::=3D {stat =
[`<B>;</B>=B4]}
</PRE>
<P>There are no empty statements and thus '<CODE>;;</CODE>' is not =
legal.=20
<P>Lua handles a chunk as the body of an anonymous function with a =
variable=20
number of arguments (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.9">=A72.5.9</A>). =
As such,=20
chunks can define local variables, receive arguments, and return values. =

<P>A chunk can be stored in a file or in a string inside the host =
program. To=20
execute a chunk, Lua first pre-compiles the chunk into instructions for =
a=20
virtual machine, and then it executes the compiled code with an =
interpreter for=20
the virtual machine.=20
<P>Chunks can also be pre-compiled into binary form; see program=20
<CODE>luac</CODE> for details. Programs in source and compiled forms are =

interchangeable; Lua automatically detects the file type and acts =
accordingly.=20
<H3>2.4.2 - <A name=3D2.4.2>Blocks</A></H3>
<P>A block is a list of statements; syntactically, a block is the same =
as a=20
chunk: <PRE>	block ::=3D chunk
</PRE>
<P>A block can be explicitly delimited to produce a single statement: =
<PRE>	stat ::=3D <B>do</B> block <B>end</B>
</PRE>
<P>Explicit blocks are useful to control the scope of variable =
declarations.=20
Explicit blocks are also sometimes used to add a <B>return</B> or =
<B>break</B>=20
statement in the middle of another block (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.4">=A72.4.4</A>).=20
<H3>2.4.3 - <A name=3D2.4.3>Assignment</A></H3>
<P>Lua allows multiple assignments. Therefore, the syntax for assignment =
defines=20
a list of variables on the left side and a list of expressions on the =
right=20
side. The elements in both lists are separated by commas: <PRE>	stat =
::=3D varlist `<B>=3D</B>=B4 explist
	varlist ::=3D var {`<B>,</B>=B4 var}
	explist ::=3D exp {`<B>,</B>=B4 exp}
</PRE>
<P>Expressions are discussed in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5">=A72.5</A>.=20
<P>Before the assignment, the list of values is <EM>adjusted</EM> to the =
length=20
of the list of variables. If there are more values than needed, the =
excess=20
values are thrown away. If there are fewer values than needed, the list =
is=20
extended with as many <B>nil</B>'s as needed. If the list of expressions =
ends=20
with a function call, then all values returned by that call enter the =
list of=20
values, before the adjustment (except when the call is enclosed in =
parentheses;=20
see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5">=A72.5</A>).=20
<P>The assignment statement first evaluates all its expressions and only =
then=20
are the assignments performed. Thus the code <PRE>     i =3D 3
     i, a[i] =3D i+1, 20
</PRE>
<P>sets <CODE>a[3]</CODE> to 20, without affecting <CODE>a[4]</CODE> =
because the=20
<CODE>i</CODE> in <CODE>a[i]</CODE> is evaluated (to 3) before it is=20
assigned&nbsp;4. Similarly, the line <PRE>     x, y =3D y, x
</PRE>
<P>exchanges the values of <CODE>x</CODE> and <CODE>y</CODE>, and <PRE>  =
   x, y, z =3D y, z, x
</PRE>
<P>cyclically permutes the values of <CODE>x</CODE>, <CODE>y</CODE>, and =

<CODE>z</CODE>.=20
<P>The meaning of assignments to global variables and table fields can =
be=20
changed via metatables. An assignment to an indexed variable <CODE>t[i] =
=3D=20
val</CODE> is equivalent to <CODE>settable_event(t,i,val)</CODE>. (See =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A> for a =
complete=20
description of the <CODE>settable_event</CODE> function. This function =
is not=20
defined or callable in Lua. We use it here only for explanatory =
purposes.)=20
<P>An assignment to a global variable <CODE>x =3D val</CODE> is =
equivalent to the=20
assignment <CODE>_env.x =3D val</CODE>, which in turn is equivalent to =
<PRE>     settable_event(_env, "x", val)
</PRE>
<P>where <CODE>_env</CODE> is the environment of the running function. =
(The=20
<CODE>_env</CODE> variable is not defined in Lua. We use it here only =
for=20
explanatory purposes.)=20
<H3>2.4.4 - <A name=3D2.4.4>Control Structures</A></H3>
<P>The control structures <B>if</B>, <B>while</B>, and <B>repeat</B> =
have the=20
usual meaning and familiar syntax: <PRE>	stat ::=3D <B>while</B> exp =
<B>do</B> block <B>end</B>
	stat ::=3D <B>repeat</B> block <B>until</B> exp
	stat ::=3D <B>if</B> exp <B>then</B> block {<B>elseif</B> exp =
<B>then</B> block} [<B>else</B> block] <B>end</B>
</PRE>
<P>Lua also has a <B>for</B> statement, in two flavors (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.5">=A72.4.5</A>).=20
<P>The condition expression of a control structure can return any value. =
Both=20
<B>false</B> and <B>nil</B> are considered false. All values different =
from=20
<B>nil</B> and <B>false</B> are considered true (in particular, the =
number 0 and=20
the empty string are also true).=20
<P>In the <B>repeat</B>=96<B>until</B> loop, the inner block does not =
end at the=20
<B>until</B> keyword, but only after the condition. So, the condition =
can refer=20
to local variables declared inside the loop block.=20
<P>The <B>return</B> statement is used to return values from a function =
or a=20
chunk (which is just a function). Functions and chunks can return more =
than one=20
value, and so the syntax for the <B>return</B> statement is <PRE>	stat =
::=3D <B>return</B> [explist]
</PRE>
<P>The <B>break</B> statement is used to terminate the execution of a=20
<B>while</B>, <B>repeat</B>, or <B>for</B> loop, skipping to the next =
statement=20
after the loop: <PRE>	stat ::=3D <B>break</B>
</PRE>
<P>A <B>break</B> ends the innermost enclosing loop.=20
<P>The <B>return</B> and <B>break</B> statements can only be written as =
the=20
<EM>last</EM> statement of a block. If it is really necessary to =
<B>return</B>=20
or <B>break</B> in the middle of a block, then an explicit inner block =
can be=20
used, as in the idioms <CODE>do return end</CODE> and <CODE>do break =
end</CODE>,=20
because now <B>return</B> and <B>break</B> are the last statements in =
their=20
(inner) blocks.=20
<H3>2.4.5 - <A name=3D2.4.5>For Statement</A></H3>
<P>The <B>for</B> statement has two forms: one numeric and one generic.=20
<P>The numeric <B>for</B> loop repeats a block of code while a control =
variable=20
runs through an arithmetic progression. It has the following syntax: =
<PRE>	stat ::=3D <B>for</B> Name `<B>=3D</B>=B4 exp `<B>,</B>=B4 exp =
[`<B>,</B>=B4 exp] <B>do</B> block <B>end</B>
</PRE>
<P>The <EM>block</EM> is repeated for <EM>name</EM> starting at the =
value of the=20
first <EM>exp</EM>, until it passes the second <EM>exp</EM> by steps of =
the=20
third <EM>exp</EM>. More precisely, a <B>for</B> statement like <PRE>    =
 for v =3D <EM>e1</EM>, <EM>e2</EM>, <EM>e3</EM> do <EM>block</EM> end
</PRE>
<P>is equivalent to the code: <PRE>     do
       local <EM>var</EM>, <EM>limit</EM>, <EM>step</EM> =3D =
tonumber(<EM>e1</EM>), tonumber(<EM>e2</EM>), tonumber(<EM>e3</EM>)
       if not (<EM>var</EM> and <EM>limit</EM> and <EM>step</EM>) then =
error() end
       while (<EM>step</EM> &gt; 0 and <EM>var</EM> &lt;=3D =
<EM>limit</EM>) or (<EM>step</EM> &lt;=3D 0 and <EM>var</EM> &gt;=3D =
<EM>limit</EM>) do
         local v =3D <EM>var</EM>
         <EM>block</EM>
         <EM>var</EM> =3D <EM>var</EM> + <EM>step</EM>
       end
     end
</PRE>
<P>Note the following:=20
<UL>
  <LI>All three control expressions are evaluated only once, before the =
loop=20
  starts. They must all result in numbers.=20
  <LI><CODE><EM>var</EM></CODE>, <CODE><EM>limit</EM></CODE>, and=20
  <CODE><EM>step</EM></CODE> are invisible variables. The names shown =
here are=20
  for explanatory purposes only.=20
  <LI>If the third expression (the step) is absent, then a step =
of&nbsp;1 is=20
  used.=20
  <LI>You can use <B>break</B> to exit a <B>for</B> loop.=20
  <LI>The loop variable <CODE>v</CODE> is local to the loop; you cannot =
use its=20
  value after the <B>for</B> ends or is broken. If you need this value, =
assign=20
  it to another variable before breaking or exiting the loop. </LI></UL>
<P>The generic <B>for</B> statement works over functions, called=20
<EM>iterators</EM>. On each iteration, the iterator function is called =
to=20
produce a new value, stopping when this new value is <B>nil</B>. The =
generic=20
<B>for</B> loop has the following syntax: <PRE>	stat ::=3D <B>for</B> =
namelist <B>in</B> explist <B>do</B> block <B>end</B>
	namelist ::=3D Name {`<B>,</B>=B4 Name}
</PRE>
<P>A <B>for</B> statement like <PRE>     for <EM>var_1</EM>, =B7=B7=B7, =
<EM>var_n</EM> in <EM>explist</EM> do <EM>block</EM> end
</PRE>
<P>is equivalent to the code: <PRE>     do
       local <EM>f</EM>, <EM>s</EM>, <EM>var</EM> =3D <EM>explist</EM>
       while true do
         local <EM>var_1</EM>, =B7=B7=B7, <EM>var_n</EM> =3D =
<EM>f</EM>(<EM>s</EM>, <EM>var</EM>)
         <EM>var</EM> =3D <EM>var_1</EM>
         if <EM>var</EM> =3D=3D nil then break end
         <EM>block</EM>
       end
     end
</PRE>
<P>Note the following:=20
<UL>
  <LI><CODE><EM>explist</EM></CODE> is evaluated only once. Its results =
are an=20
  <EM>iterator</EM> function, a <EM>state</EM>, and an initial value for =
the=20
  first <EM>iterator variable</EM>.=20
  <LI><CODE><EM>f</EM></CODE>, <CODE><EM>s</EM></CODE>, and=20
  <CODE><EM>var</EM></CODE> are invisible variables. The names are here =
for=20
  explanatory purposes only.=20
  <LI>You can use <B>break</B> to exit a <B>for</B> loop.=20
  <LI>The loop variables <CODE><EM>var_i</EM></CODE> are local to the =
loop; you=20
  cannot use their values after the <B>for</B> ends. If you need these =
values,=20
  then assign them to other variables before breaking or exiting the =
loop.=20
</LI></UL>
<H3>2.4.6 - <A name=3D2.4.6>Function Calls as Statements</A></H3>
<P>To allow possible side-effects, function calls can be executed as =
statements:=20
<PRE>	stat ::=3D functioncall
</PRE>
<P>In this case, all returned values are thrown away. Function calls are =

explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.8">=A72.5.8</A>.=20
<H3>2.4.7 - <A name=3D2.4.7>Local Declarations</A></H3>
<P>Local variables can be declared anywhere inside a block. The =
declaration can=20
include an initial assignment: <PRE>	stat ::=3D <B>local</B> namelist =
[`<B>=3D</B>=B4 explist]
</PRE>
<P>If present, an initial assignment has the same semantics of a =
multiple=20
assignment (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.3">=A72.4.3</A>). =
Otherwise,=20
all variables are initialized with <B>nil</B>.=20
<P>A chunk is also a block (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.1">=A72.4.1</A>), =
and so local=20
variables can be declared in a chunk outside any explicit block. The =
scope of=20
such local variables extends until the end of the chunk.=20
<P>The visibility rules for local variables are explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.6">=A72.6</A>.=20
<H2>2.5 - <A name=3D2.5>Expressions</A></H2>
<P>The basic expressions in Lua are the following: <PRE>	exp ::=3D =
prefixexp
	exp ::=3D <B>nil</B> | <B>false</B> | <B>true</B>
	exp ::=3D Number
	exp ::=3D String
	exp ::=3D function
	exp ::=3D tableconstructor
	exp ::=3D `<B>...</B>=B4
	exp ::=3D exp binop exp
	exp ::=3D unop exp
	prefixexp ::=3D var | functioncall | `<B>(</B>=B4 exp `<B>)</B>=B4
</PRE>
<P>Numbers and literal strings are explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.1">=A72.1</A>; =
variables are=20
explained in <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.3">=A72.3</A>;=20
function definitions are explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.9">=A72.5.9</A>; =
function=20
calls are explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.8">=A72.5.8</A>; =
table=20
constructors are explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.7">=A72.5.7</A>. =
Vararg=20
expressions, denoted by three dots ('<CODE>...</CODE>'), can only be =
used when=20
directly inside a vararg function; they are explained in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.9">=A72.5.9</A>.=20
<P>Binary operators comprise arithmetic operators (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.1">=A72.5.1</A>), =
relational=20
operators (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.2">=A72.5.2</A>), =
logical=20
operators (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.3">=A72.5.3</A>), =
and the=20
concatenation operator (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.4">=A72.5.4</A>). =
Unary=20
operators comprise the unary minus (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.1">=A72.5.1</A>), =
the unary=20
<B>not</B> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.3">=A72.5.3</A>), =
and the=20
unary <EM>length operator</EM> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.5">=A72.5.5</A>).=20
<P>Both function calls and vararg expressions can result in multiple =
values. If=20
an expression is used as a statement (only possible for function calls =
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.6">=A72.4.6</A>)), =
then its=20
return list is adjusted to zero elements, thus discarding all returned =
values.=20
If an expression is used as the last (or the only) element of a list of=20
expressions, then no adjustment is made (unless the call is enclosed in=20
parentheses). In all other contexts, Lua adjusts the result list to one =
element,=20
discarding all values except the first one.=20
<P>Here are some examples: <PRE>     f()                -- adjusted to 0 =
results
     g(f(), x)          -- f() is adjusted to 1 result
     g(x, f())          -- g gets x plus all results from f()
     a,b,c =3D f(), x     -- f() is adjusted to 1 result (c gets nil)
     a,b =3D ...          -- a gets the first vararg parameter, b gets
                        -- the second (both a and b can get nil if there
                        -- is no corresponding vararg parameter)
    =20
     a,b,c =3D x, f()     -- f() is adjusted to 2 results
     a,b,c =3D f()        -- f() is adjusted to 3 results
     return f()         -- returns all results from f()
     return ...         -- returns all received vararg parameters
     return x,y,f()     -- returns x, y, and all results from f()
     {f()}              -- creates a list with all results from f()
     {...}              -- creates a list with all vararg parameters
     {f(), nil}         -- f() is adjusted to 1 result
</PRE>
<P>Any expression enclosed in parentheses always results in only one =
value.=20
Thus, <CODE>(f(x,y,z))</CODE> is always a single value, even if =
<CODE>f</CODE>=20
returns several values. (The value of <CODE>(f(x,y,z))</CODE> is the =
first value=20
returned by <CODE>f</CODE> or <B>nil</B> if <CODE>f</CODE> does not =
return any=20
values.)=20
<H3>2.5.1 - <A name=3D2.5.1>Arithmetic Operators</A></H3>
<P>Lua supports the usual arithmetic operators: the binary =
<CODE>+</CODE>=20
(addition), <CODE>-</CODE> (subtraction), <CODE>*</CODE> =
(multiplication),=20
<CODE>/</CODE> (division), <CODE>%</CODE> (modulo), and <CODE>^</CODE>=20
(exponentiation); and unary <CODE>-</CODE> (negation). If the operands =
are=20
numbers, or strings that can be converted to numbers (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.2.1">=A72.2.1</A>), =
then all=20
operations have the usual meaning. Exponentiation works for any =
exponent. For=20
instance, <CODE>x^(-0.5)</CODE> computes the inverse of the square root =
of=20
<CODE>x</CODE>. Modulo is defined as <PRE>     a % b =3D=3D a - =
math.floor(a/b)*b
</PRE>
<P>That is, it is the remainder of a division that rounds the quotient =
towards=20
minus infinity.=20
<H3>2.5.2 - <A name=3D2.5.2>Relational Operators</A></H3>
<P>The relational operators in Lua are <PRE>     =3D=3D    ~=3D    &lt;  =
   &gt;     &lt;=3D    &gt;=3D
</PRE>
<P>These operators always result in <B>false</B> or <B>true</B>.=20
<P>Equality (<CODE>=3D=3D</CODE>) first compares the type of its =
operands. If the=20
types are different, then the result is <B>false</B>. Otherwise, the =
values of=20
the operands are compared. Numbers and strings are compared in the usual =
way.=20
Objects (tables, userdata, threads, and functions) are compared by=20
<EM>reference</EM>: two objects are considered equal only if they are =
the=20
<EM>same</EM> object. Every time you create a new object (a table, =
userdata,=20
thread, or function), this new object is different from any previously =
existing=20
object.=20
<P>You can change the way that Lua compares tables and userdata by using =
the=20
"eq" metamethod (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<P>The conversion rules of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.2.1">=A72.2.1</A> =
<EM>do=20
not</EM> apply to equality comparisons. Thus, <CODE>"0"=3D=3D0</CODE> =
evaluates to=20
<B>false</B>, and <CODE>t[0]</CODE> and <CODE>t["0"]</CODE> denote =
different=20
entries in a table.=20
<P>The operator <CODE>~=3D</CODE> is exactly the negation of equality=20
(<CODE>=3D=3D</CODE>).=20
<P>The order operators work as follows. If both arguments are numbers, =
then they=20
are compared as such. Otherwise, if both arguments are strings, then =
their=20
values are compared according to the current locale. Otherwise, Lua =
tries to=20
call the "lt" or the "le" metamethod (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>). A =
comparison=20
<CODE>a &gt; b</CODE> is translated to <CODE>b &lt; a</CODE> and <CODE>a =
&gt;=3D=20
b</CODE> is translated to <CODE>b &lt;=3D a</CODE>.=20
<H3>2.5.3 - <A name=3D2.5.3>Logical Operators</A></H3>
<P>The logical operators in Lua are <B>and</B>, <B>or</B>, and =
<B>not</B>. Like=20
the control structures (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.4">=A72.4.4</A>), =
all logical=20
operators consider both <B>false</B> and <B>nil</B> as false and =
anything else=20
as true.=20
<P>The negation operator <B>not</B> always returns <B>false</B> or =
<B>true</B>.=20
The conjunction operator <B>and</B> returns its first argument if this =
value is=20
<B>false</B> or <B>nil</B>; otherwise, <B>and</B> returns its second =
argument.=20
The disjunction operator <B>or</B> returns its first argument if this =
value is=20
different from <B>nil</B> and <B>false</B>; otherwise, <B>or</B> returns =
its=20
second argument. Both <B>and</B> and <B>or</B> use short-cut evaluation; =
that=20
is, the second operand is evaluated only if necessary. Here are some =
examples: <PRE>     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</PRE>
<P>(In this manual, <CODE>--&gt;</CODE> indicates the result of the =
preceding=20
expression.)=20
<H3>2.5.4 - <A name=3D2.5.4>Concatenation</A></H3>
<P>The string concatenation operator in Lua is denoted by two dots=20
('<CODE>..</CODE>'). If both operands are strings or numbers, then they =
are=20
converted to strings according to the rules mentioned in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.2.1">=A72.2.1</A>. =
Otherwise,=20
the "concat" metamethod is called (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<H3>2.5.5 - <A name=3D2.5.5>The Length Operator</A></H3>
<P>The length operator is denoted by the unary operator <CODE>#</CODE>. =
The=20
length of a string is its number of bytes (that is, the usual meaning of =
string=20
length when each character is one byte).=20
<P>The length of a table <CODE>t</CODE> is defined to be any integer =
index=20
<CODE>n</CODE> such that <CODE>t[n]</CODE> is not <B>nil</B> and=20
<CODE>t[n+1]</CODE> is <B>nil</B>; moreover, if <CODE>t[1]</CODE> is =
<B>nil</B>,=20
<CODE>n</CODE> can be zero. For a regular array, with non-nil values =
from 1 to a=20
given <CODE>n</CODE>, its length is exactly that <CODE>n</CODE>, the =
index of=20
its last value. If the array has "holes" (that is, <B>nil</B> values =
between=20
other non-nil values), then <CODE>#t</CODE> can be any of the indices =
that=20
directly precedes a <B>nil</B> value (that is, it may consider any such=20
<B>nil</B> value as the end of the array).=20
<H3>2.5.6 - <A name=3D2.5.6>Precedence</A></H3>
<P>Operator precedence in Lua follows the table below, from lower to =
higher=20
priority: <PRE>     or
     and
     &lt;     &gt;     &lt;=3D    &gt;=3D    ~=3D    =3D=3D
     ..
     +     -
     *     /     %
     not   #     - (unary)
     ^
</PRE>
<P>As usual, you can use parentheses to change the precedences of an =
expression.=20
The concatenation ('<CODE>..</CODE>') and exponentiation =
('<CODE>^</CODE>')=20
operators are right associative. All other binary operators are left=20
associative.=20
<H3>2.5.7 - <A name=3D2.5.7>Table Constructors</A></H3>
<P>Table constructors are expressions that create tables. Every time a=20
constructor is evaluated, a new table is created. A constructor can be =
used to=20
create an empty table or to create a table and initialize some of its =
fields.=20
The general syntax for constructors is <PRE>	tableconstructor ::=3D =
`<B>{</B>=B4 [fieldlist] `<B>}</B>=B4
	fieldlist ::=3D field {fieldsep field} [fieldsep]
	field ::=3D `<B>[</B>=B4 exp `<B>]</B>=B4 `<B>=3D</B>=B4 exp | Name =
`<B>=3D</B>=B4 exp | exp
	fieldsep ::=3D `<B>,</B>=B4 | `<B>;</B>=B4
</PRE>
<P>Each field of the form <CODE>[exp1] =3D exp2</CODE> adds to the new =
table an=20
entry with key <CODE>exp1</CODE> and value <CODE>exp2</CODE>. A field of =
the=20
form <CODE>name =3D exp</CODE> is equivalent to <CODE>["name"] =3D =
exp</CODE>.=20
Finally, fields of the form <CODE>exp</CODE> are equivalent to <CODE>[i] =
=3D=20
exp</CODE>, where <CODE>i</CODE> are consecutive numerical integers, =
starting=20
with 1. Fields in the other formats do not affect this counting. For =
example, <PRE>     a =3D { [f(1)] =3D g; "x", "y"; x =3D 1, f(x), [30] =
=3D 23; 45 }
</PRE>
<P>is equivalent to <PRE>     do
       local t =3D {}
       t[f(1)] =3D g
       t[1] =3D "x"         -- 1st exp
       t[2] =3D "y"         -- 2nd exp
       t.x =3D 1            -- t["x"] =3D 1
       t[3] =3D f(x)        -- 3rd exp
       t[30] =3D 23
       t[4] =3D 45          -- 4th exp
       a =3D t
     end
</PRE>
<P>If the last field in the list has the form <CODE>exp</CODE> and the=20
expression is a function call or a vararg expression, then all values =
returned=20
by this expression enter the list consecutively (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.8">=A72.5.8</A>). =
To avoid=20
this, enclose the function call or the vararg expression in parentheses =
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5">=A72.5</A>).=20
<P>The field list can have an optional trailing separator, as a =
convenience for=20
machine-generated code.=20
<H3>2.5.8 - <A name=3D2.5.8>Function Calls</A></H3>
<P>A function call in Lua has the following syntax: <PRE>	functioncall =
::=3D prefixexp args
</PRE>
<P>In a function call, first prefixexp and args are evaluated. If the =
value of=20
prefixexp has type <EM>function</EM>, then this function is called with =
the=20
given arguments. Otherwise, the prefixexp "call" metamethod is called, =
having as=20
first parameter the value of prefixexp, followed by the original call =
arguments=20
(see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<P>The form <PRE>	functioncall ::=3D prefixexp `<B>:</B>=B4 Name args
</PRE>
<P>can be used to call "methods". A call =
<CODE>v:name(<EM>args</EM>)</CODE> is=20
syntactic sugar for <CODE>v.name(v,<EM>args</EM>)</CODE>, except that=20
<CODE>v</CODE> is evaluated only once.=20
<P>Arguments have the following syntax: <PRE>	args ::=3D `<B>(</B>=B4 =
[explist] `<B>)</B>=B4
	args ::=3D tableconstructor
	args ::=3D String
</PRE>
<P>All argument expressions are evaluated before the call. A call of the =
form=20
<CODE>f{<EM>fields</EM>}</CODE> is syntactic sugar for=20
<CODE>f({<EM>fields</EM>})</CODE>; that is, the argument list is a =
single new=20
table. A call of the form <CODE>f'<EM>string</EM>'</CODE> (or=20
<CODE>f"<EM>string</EM>"</CODE> or <CODE>f[[<EM>string</EM>]]</CODE>) is =

syntactic sugar for <CODE>f('<EM>string</EM>')</CODE>; that is, the =
argument=20
list is a single literal string.=20
<P>As an exception to the free-format syntax of Lua, you cannot put a =
line break=20
before the '<CODE>(</CODE>' in a function call. This restriction avoids =
some=20
ambiguities in the language. If you write <PRE>     a =3D f
     (g).x(a)
</PRE>
<P>Lua would see that as a single statement, <CODE>a =3D =
f(g).x(a)</CODE>. So, if=20
you want two statements, you must add a semi-colon between them. If you =
actually=20
want to call <CODE>f</CODE>, you must remove the line break before=20
<CODE>(g)</CODE>.=20
<P>A call of the form <CODE>return</CODE> <EM>functioncall</EM> is =
called a=20
<EM>tail call</EM>. Lua implements <EM>proper tail calls</EM> (or =
<EM>proper=20
tail recursion</EM>): in a tail call, the called function reuses the =
stack entry=20
of the calling function. Therefore, there is no limit on the number of =
nested=20
tail calls that a program can execute. However, a tail call erases any =
debug=20
information about the calling function. Note that a tail call only =
happens with=20
a particular syntax, where the <B>return</B> has one single function =
call as=20
argument; this syntax makes the calling function return exactly the =
returns of=20
the called function. So, none of the following examples are tail calls: =
<PRE>     return (f(x))        -- results adjusted to 1
     return 2 * f(x)
     return x, f(x)       -- additional results
     f(x); return         -- results discarded
     return x or f(x)     -- results adjusted to 1
</PRE>
<H3>2.5.9 - <A name=3D2.5.9>Function Definitions</A></H3>
<P>The syntax for function definition is <PRE>	function ::=3D =
<B>function</B> funcbody
	funcbody ::=3D `<B>(</B>=B4 [parlist] `<B>)</B>=B4 block <B>end</B>
</PRE>
<P>The following syntactic sugar simplifies function definitions: <PRE>	=
stat ::=3D <B>function</B> funcname funcbody
	stat ::=3D <B>local</B> <B>function</B> Name funcbody
	funcname ::=3D Name {`<B>.</B>=B4 Name} [`<B>:</B>=B4 Name]
</PRE>
<P>The statement <PRE>     function f () <EM>body</EM> end
</PRE>
<P>translates to <PRE>     f =3D function () <EM>body</EM> end
</PRE>
<P>The statement <PRE>     function t.a.b.c.f () <EM>body</EM> end
</PRE>
<P>translates to <PRE>     t.a.b.c.f =3D function () <EM>body</EM> end
</PRE>
<P>The statement <PRE>     local function f () <EM>body</EM> end
</PRE>
<P>translates to <PRE>     local f; f =3D function () <EM>body</EM> end
</PRE>
<P><EM>not</EM> to <PRE>     local f =3D function () <EM>body</EM> end
</PRE>
<P>(This only makes a difference when the body of the function contains=20
references to <CODE>f</CODE>.)=20
<P>A function definition is an executable expression, whose value has =
type=20
<EM>function</EM>. When Lua pre-compiles a chunk, all its function =
bodies are=20
pre-compiled too. Then, whenever Lua executes the function definition, =
the=20
function is <EM>instantiated</EM> (or <EM>closed</EM>). This function =
instance=20
(or <EM>closure</EM>) is the final value of the expression. Different =
instances=20
of the same function can refer to different external local variables and =
can=20
have different environment tables.=20
<P>Parameters act as local variables that are initialized with the =
argument=20
values: <PRE>	parlist ::=3D namelist [`<B>,</B>=B4 `<B>...</B>=B4] | =
`<B>...</B>=B4
</PRE>
<P>When a function is called, the list of arguments is adjusted to the =
length of=20
the list of parameters, unless the function is a variadic or <EM>vararg=20
function</EM>, which is indicated by three dots ('<CODE>...</CODE>') at =
the end=20
of its parameter list. A vararg function does not adjust its argument =
list;=20
instead, it collects all extra arguments and supplies them to the =
function=20
through a <EM>vararg expression</EM>, which is also written as three =
dots. The=20
value of this expression is a list of all actual extra arguments, =
similar to a=20
function with multiple results. If a vararg expression is used inside =
another=20
expression or in the middle of a list of expressions, then its return =
list is=20
adjusted to one element. If the expression is used as the last element =
of a list=20
of expressions, then no adjustment is made (unless that last expression =
is=20
enclosed in parentheses).=20
<P>As an example, consider the following definitions: <PRE>     function =
f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</PRE>
<P>Then, we have the following mapping from arguments to parameters and =
to the=20
vararg expression: <PRE>     CALL            PARAMETERS
    =20
     f(3)             a=3D3, b=3Dnil
     f(3, 4)          a=3D3, b=3D4
     f(3, 4, 5)       a=3D3, b=3D4
     f(r(), 10)       a=3D1, b=3D10
     f(r())           a=3D1, b=3D2
    =20
     g(3)             a=3D3, b=3Dnil, ... --&gt;  (nothing)
     g(3, 4)          a=3D3, b=3D4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3D3, b=3D4,   ... --&gt;  5  8
     g(5, r())        a=3D5, b=3D1,   ... --&gt;  2  3
</PRE>
<P>Results are returned using the <B>return</B> statement (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.4.4">=A72.4.4</A>). =
If control=20
reaches the end of a function without encountering a <B>return</B> =
statement,=20
then the function returns with no results.=20
<P>The <EM>colon</EM> syntax is used for defining <EM>methods</EM>, that =
is,=20
functions that have an implicit extra parameter <CODE>self</CODE>. Thus, =
the=20
statement <PRE>     function t.a.b.c:f (<EM>params</EM>) <EM>body</EM> =
end
</PRE>
<P>is syntactic sugar for <PRE>     t.a.b.c.f =3D function (self, =
<EM>params</EM>) <EM>body</EM> end
</PRE>
<H2>2.6 - <A name=3D2.6>Visibility Rules</A></H2>
<P>Lua is a lexically scoped language. The scope of variables begins at =
the=20
first statement <EM>after</EM> their declaration and lasts until the end =
of the=20
innermost block that includes the declaration. Consider the following =
example: <PRE>     x =3D 10                -- global variable
     do                    -- new block
       local x =3D x         -- new 'x', with value 10
       print(x)            --&gt; 10
       x =3D x+1
       do                  -- another block
         local x =3D x+1     -- another 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (the global one)
</PRE>
<P>Notice that, in a declaration like <CODE>local x =3D x</CODE>, the =
new=20
<CODE>x</CODE> being declared is not in scope yet, and so the second=20
<CODE>x</CODE> refers to the outside variable.=20
<P>Because of the lexical scoping rules, local variables can be freely =
accessed=20
by functions defined inside their scope. A local variable used by an =
inner=20
function is called an <EM>upvalue</EM>, or <EM>external local =
variable</EM>,=20
inside the inner function.=20
<P>Notice that each execution of a <B>local</B> statement defines new =
local=20
variables. Consider the following example: <PRE>     a =3D {}
     local x =3D 20
     for i=3D1,10 do
       local y =3D 0
       a[i] =3D function () y=3Dy+1; return x+y end
     end
</PRE>
<P>The loop creates ten closures (that is, ten instances of the =
anonymous=20
function). Each of these closures uses a different <CODE>y</CODE> =
variable,=20
while all of them share the same <CODE>x</CODE>.=20
<H2>2.7 - <A name=3D2.7>Error Handling</A></H2>
<P>Because Lua is an embedded extension language, all Lua actions start =
from=20
C&nbsp;code in the host program calling a function from the Lua library =
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>).=20
Whenever an error occurs during Lua compilation or execution, control =
returns to=20
C, which can take appropriate measures (such as printing an error =
message).=20
<P>Lua code can explicitly generate an error by calling the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-error"><CODE>error<=
/CODE></A>=20
function. If you need to catch errors in Lua, you can use the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-pcall"><CODE>pcall<=
/CODE></A>=20
function.=20
<H2>2.8 - <A name=3D2.8>Metatables</A></H2>
<P>Every value in Lua can have a <EM>metatable</EM>. This =
<EM>metatable</EM> is=20
an ordinary Lua table that defines the behavior of the original value =
under=20
certain special operations. You can change several aspects of the =
behavior of=20
operations over a value by setting specific fields in its metatable. For =

instance, when a non-numeric value is the operand of an addition, Lua =
checks for=20
a function in the field <CODE>"__add"</CODE> in its metatable. If it =
finds one,=20
Lua calls this function to perform the addition.=20
<P>We call the keys in a metatable <EM>events</EM> and the values=20
<EM>metamethods</EM>. In the previous example, the event is =
<CODE>"add"</CODE>=20
and the metamethod is the function that performs the addition.=20
<P>You can query the metatable of any value through the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-getmetatable"><CODE=
>getmetatable</CODE></A>=20
function.=20
<P>You can replace the metatable of tables through the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-setmetatable"><CODE=
>setmetatable</CODE></A>=20
function. You cannot change the metatable of other types from Lua =
(except by=20
using the debug library); you must use the C&nbsp;API for that.=20
<P>Tables and full userdata have individual metatables (although =
multiple tables=20
and userdata can share their metatables). Values of all other types =
share one=20
single metatable per type; that is, there is one single metatable for =
all=20
numbers, one for all strings, etc.=20
<P>A metatable controls how an object behaves in arithmetic operations, =
order=20
comparisons, concatenation, length operation, and indexing. A metatable =
also can=20
define a function to be called when a userdata is garbage collected. For =
each of=20
these operations Lua associates a specific key called an <EM>event</EM>. =
When=20
Lua performs one of these operations over a value, it checks whether =
this value=20
has a metatable with the corresponding event. If so, the value =
associated with=20
that key (the metamethod) controls how Lua will perform the operation.=20
<P>Metatables control the operations listed next. Each operation is =
identified=20
by its corresponding name. The key for each operation is a string with =
its name=20
prefixed by two underscores, '<CODE>__</CODE>'; for instance, the key =
for=20
operation "add" is the string <CODE>"__add"</CODE>. The semantics of =
these=20
operations is better explained by a Lua function describing how the =
interpreter=20
executes the operation.=20
<P>The code shown here in Lua is only illustrative; the real behavior is =
hard=20
coded in the interpreter and it is much more efficient than this =
simulation. All=20
functions used in these descriptions (<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-rawget"><CODE>rawge=
t</CODE></A>,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-tonumber"><CODE>ton=
umber</CODE></A>,=20
etc.) are described in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#5.1">=A75.1</A>. In =
particular, to=20
retrieve the metamethod of a given object, we use the expression <PRE>   =
  metatable(obj)[event]
</PRE>
<P>This should be read as <PRE>     rawget(getmetatable(obj) or {}, =
event)
</PRE>
<P>That is, the access to a metamethod does not invoke other =
metamethods, and=20
the access to objects with no metatables does not fail (it simply =
results in=20
<B>nil</B>).=20
<UL>
  <LI><B>"add":</B> the <CODE>+</CODE> operation.=20
  <P>The function <CODE>getbinhandler</CODE> below defines how Lua =
chooses a=20
  handler for a binary operation. First, Lua tries the first operand. If =
its=20
  type does not define a handler for the operation, then Lua tries the =
second=20
  operand. <PRE>     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end
</PRE>
  <P>By using this function, the behavior of the <CODE>op1 + op2</CODE> =
is <PRE>     function add_event (op1, op2)
       local o1, o2 =3D tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- both operands are numeric?
         return o1 + o2   -- '+' here is the primitive 'add'
       else  -- at least one of the operands is not numeric
         local h =3D getbinhandler(op1, op2, "__add")
         if h then
           -- call the handler with both operands
           return (h(op1, op2))
         else  -- no handler available: default behavior
           error(=B7=B7=B7)
         end
       end
     end
</PRE>
  <P></P>
  <LI><B>"sub":</B> the <CODE>-</CODE> operation. Behavior similar to =
the "add"=20
  operation.=20
  <LI><B>"mul":</B> the <CODE>*</CODE> operation. Behavior similar to =
the "add"=20
  operation.=20
  <LI><B>"div":</B> the <CODE>/</CODE> operation. Behavior similar to =
the "add"=20
  operation.=20
  <LI><B>"mod":</B> the <CODE>%</CODE> operation. Behavior similar to =
the "add"=20
  operation, with the operation <CODE>o1 - floor(o1/o2)*o2</CODE> as the =

  primitive operation.=20
  <LI><B>"pow":</B> the <CODE>^</CODE> (exponentiation) operation. =
Behavior=20
  similar to the "add" operation, with the function <CODE>pow</CODE> =
(from the=20
  C&nbsp;math library) as the primitive operation.=20
  <LI><B>"unm":</B> the unary <CODE>-</CODE> operation. <PRE>     =
function unm_event (op)
       local o =3D tonumber(op)
       if o then  -- operand is numeric?
         return -o  -- '-' here is the primitive 'unm'
       else  -- the operand is not numeric.
         -- Try to get a handler from the operand
         local h =3D metatable(op).__unm
         if h then
           -- call the handler with the operand
           return (h(op))
         else  -- no handler available: default behavior
           error(=B7=B7=B7)
         end
       end
     end
</PRE>
  <P></P>
  <LI><B>"concat":</B> the <CODE>..</CODE> (concatenation) operation. =
<PRE>     function concat_event (op1, op2)
       if (type(op1) =3D=3D "string" or type(op1) =3D=3D "number") and
          (type(op2) =3D=3D "string" or type(op2) =3D=3D "number") then
         return op1 .. op2  -- primitive string concatenation
       else
         local h =3D getbinhandler(op1, op2, "__concat")
         if h then
           return (h(op1, op2))
         else
           error(=B7=B7=B7)
         end
       end
     end
</PRE>
  <P></P>
  <LI><B>"len":</B> the <CODE>#</CODE> operation. <PRE>     function =
len_event (op)
       if type(op) =3D=3D "string" then
         return strlen(op)         -- primitive string length
       elseif type(op) =3D=3D "table" then
         return #op                -- primitive table length
       else
         local h =3D metatable(op).__len
         if h then
           -- call the handler with the operand
           return (h(op))
         else  -- no handler available: default behavior
           error(=B7=B7=B7)
         end
       end
     end
</PRE>
  <P>See <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.5">=A72.5.5</A>=20
  for a description of the length of a table. </P>
  <LI><B>"eq":</B> the <CODE>=3D=3D</CODE> operation. The function=20
  <CODE>getcomphandler</CODE> defines how Lua chooses a metamethod for=20
  comparison operators. A metamethod only is selected when both objects =
being=20
  compared have the same type and the same metamethod for the selected=20
  operation. <PRE>     function getcomphandler (op1, op2, event)
       if type(op1) ~=3D type(op2) then return nil end
       local mm1 =3D metatable(op1)[event]
       local mm2 =3D metatable(op2)[event]
       if mm1 =3D=3D mm2 then return mm1 else return nil end
     end
</PRE>
  <P>The "eq" event is defined as follows: <PRE>     function eq_event =
(op1, op2)
       if type(op1) ~=3D type(op2) then  -- different types?
         return false   -- different objects
       end
       if op1 =3D=3D op2 then   -- primitive equal?
         return true   -- objects are equal
       end
       -- try metamethod
       local h =3D getcomphandler(op1, op2, "__eq")
       if h then
         return (h(op1, op2))
       else
         return false
       end
     end
</PRE>
  <P><CODE>a ~=3D b</CODE> is equivalent to <CODE>not (a =3D=3D =
b)</CODE>. </P>
  <LI><B>"lt":</B> the <CODE>&lt;</CODE> operation. <PRE>     function =
lt_event (op1, op2)
       if type(op1) =3D=3D "number" and type(op2) =3D=3D "number" then
         return op1 &lt; op2   -- numeric comparison
       elseif type(op1) =3D=3D "string" and type(op2) =3D=3D "string" =
then
         return op1 &lt; op2   -- lexicographic comparison
       else
         local h =3D getcomphandler(op1, op2, "__lt")
         if h then
           return (h(op1, op2))
         else
           error(=B7=B7=B7)
         end
       end
     end
</PRE>
  <P><CODE>a &gt; b</CODE> is equivalent to <CODE>b &lt; a</CODE>. </P>
  <LI><B>"le":</B> the <CODE>&lt;=3D</CODE> operation. <PRE>     =
function le_event (op1, op2)
       if type(op1) =3D=3D "number" and type(op2) =3D=3D "number" then
         return op1 &lt;=3D op2   -- numeric comparison
       elseif type(op1) =3D=3D "string" and type(op2) =3D=3D "string" =
then
         return op1 &lt;=3D op2   -- lexicographic comparison
       else
         local h =3D getcomphandler(op1, op2, "__le")
         if h then
           return (h(op1, op2))
         else
           h =3D getcomphandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error(=B7=B7=B7)
           end
         end
       end
     end
</PRE>
  <P><CODE>a &gt;=3D b</CODE> is equivalent to <CODE>b &lt;=3D a</CODE>. =
Note that,=20
  in the absence of a "le" metamethod, Lua tries the "lt", assuming that =
<CODE>a=20
  &lt;=3D b</CODE> is equivalent to <CODE>not (b &lt; a)</CODE>. </P>
  <LI><B>"index":</B> The indexing access <CODE>table[key]</CODE>. <PRE> =
    function gettable_event (table, key)
       local h
       if type(table) =3D=3D "table" then
         local v =3D rawget(table, key)
         if v ~=3D nil then return v end
         h =3D metatable(table).__index
         if h =3D=3D nil then return nil end
       else
         h =3D metatable(table).__index
         if h =3D=3D nil then
           error(=B7=B7=B7)
         end
       end
       if type(h) =3D=3D "function" then
         return (h(table, key))     -- call the handler
       else return h[key]           -- or repeat operation on it
       end
     end
</PRE>
  <P></P>
  <LI><B>"newindex":</B> The indexing assignment <CODE>table[key] =3D=20
  value</CODE>. <PRE>     function settable_event (table, key, value)
       local h
       if type(table) =3D=3D "table" then
         local v =3D rawget(table, key)
         if v ~=3D nil then rawset(table, key, value); return end
         h =3D metatable(table).__newindex
         if h =3D=3D nil then rawset(table, key, value); return end
       else
         h =3D metatable(table).__newindex
         if h =3D=3D nil then
           error(=B7=B7=B7)
         end
       end
       if type(h) =3D=3D "function" then
         h(table, key,value)           -- call the handler
       else h[key] =3D value             -- or repeat operation on it
       end
     end
</PRE>
  <P></P>
  <LI><B>"call":</B> called when Lua calls a value. <PRE>     function =
function_event (func, ...)
       if type(func) =3D=3D "function" then
         return func(...)   -- primitive call
       else
         local h =3D metatable(func).__call
         if h then
           return h(func, ...)
         else
           error(=B7=B7=B7)
         end
       end
     end
</PRE>
  <P></P></LI></UL>
<H2>2.9 - <A name=3D2.9>Environments</A></H2>
<P>Besides metatables, objects of types thread, function, and userdata =
have=20
another table associated with them, called their <EM>environment</EM>. =
Like=20
metatables, environments are regular tables and multiple objects can =
share the=20
same environment.=20
<P>Threads are created sharing the environment of the creating thread. =
Userdata=20
and C&nbsp;functions are created sharing the environment of the creating =

C&nbsp;function. Non-nested Lua functions (created by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-loadfile"><CODE>loa=
dfile</CODE></A>,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-loadstring"><CODE>l=
oadstring</CODE></A>=20
or <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-load"><CODE>load</C=
ODE></A>)=20
are created sharing the environment of the creating thread. Nested Lua =
functions=20
are created sharing the environment of the creating Lua function.=20
<P>Environments associated with userdata have no meaning for Lua. It is =
only a=20
convenience feature for programmers to associate a table to a userdata.=20
<P>Environments associated with threads are called <EM>global =
environments</EM>.=20
They are used as the default environment for threads and non-nested Lua=20
functions created by the thread and can be directly accessed by =
C&nbsp;code (see=20
<A href=3D"http://www.lua.org/manual/5.1/manual.html#3.3">=A73.3</A>).=20
<P>The environment associated with a C&nbsp;function can be directly =
accessed by=20
C&nbsp;code (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#3.3">=A73.3</A>). It =
is used as=20
the default environment for other C&nbsp;functions and userdata created =
by the=20
function.=20
<P>Environments associated with Lua functions are used to resolve all =
accesses=20
to global variables within the function (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.3">=A72.3</A>). They =
are used as=20
the default environment for nested Lua functions created by the =
function.=20
<P>You can change the environment of a Lua function or the running =
thread by=20
calling <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-setfenv"><CODE>setf=
env</CODE></A>.=20
You can get the environment of a Lua function or the running thread by =
calling=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-getfenv"><CODE>getf=
env</CODE></A>.=20
To manipulate the environment of other objects (userdata, =
C&nbsp;functions,=20
other threads) you must use the C&nbsp;API.=20
<H2>2.10 - <A name=3D2.10>Garbage Collection</A></H2>
<P>Lua performs automatic memory management. This means that you have to =
worry=20
neither about allocating memory for new objects nor about freeing it =
when the=20
objects are no longer needed. Lua manages memory automatically by =
running a=20
<EM>garbage collector</EM> from time to time to collect all <EM>dead=20
objects</EM> (that is, objects that are no longer accessible from Lua). =
All=20
memory used by Lua is subject to automatic management: tables, userdata, =

functions, threads, strings, etc.=20
<P>Lua implements an incremental mark-and-sweep collector. It uses two =
numbers=20
to control its garbage-collection cycles: the <EM>garbage-collector =
pause</EM>=20
and the <EM>garbage-collector step multiplier</EM>. Both use percentage =
points=20
as units (so that a value of 100 means an internal value of 1).=20
<P>The garbage-collector pause controls how long the collector waits =
before=20
starting a new cycle. Larger values make the collector less aggressive. =
Values=20
smaller than 100 mean the collector will not wait to start a new cycle. =
A value=20
of 200 means that the collector waits for the total memory in use to =
double=20
before starting a new cycle.=20
<P>The step multiplier controls the relative speed of the collector =
relative to=20
memory allocation. Larger values make the collector more aggressive but =
also=20
increase the size of each incremental step. Values smaller than 100 make =
the=20
collector too slow and can result in the collector never finishing a =
cycle. The=20
default, 200, means that the collector runs at "twice" the speed of =
memory=20
allocation.=20
<P>You can change these numbers by calling <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_gc"><CODE>lua_gc</C=
ODE></A>=20
in C or <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage"><CO=
DE>collectgarbage</CODE></A>=20
in Lua. With these functions you can also control the collector directly =
(e.g.,=20
stop and restart it).=20
<H3>2.10.1 - <A name=3D2.10.1>Garbage-Collection Metamethods</A></H3>
<P>Using the C&nbsp;API, you can set garbage-collector metamethods for =
userdata=20
(see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>). =
These=20
metamethods are also called <EM>finalizers</EM>. Finalizers allow you to =

coordinate Lua's garbage collection with external resource management =
(such as=20
closing files, network or database connections, or freeing your own =
memory).=20
<P>Garbage userdata with a field <CODE>__gc</CODE> in their metatables =
are not=20
collected immediately by the garbage collector. Instead, Lua puts them =
in a=20
list. After the collection, Lua does the equivalent of the following =
function=20
for each userdata in that list: <PRE>     function gc_event (udata)
       local h =3D metatable(udata).__gc
       if h then
         h(udata)
       end
     end
</PRE>
<P>At the end of each garbage-collection cycle, the finalizers for =
userdata are=20
called in <EM>reverse</EM> order of their creation, among those =
collected in=20
that cycle. That is, the first finalizer to be called is the one =
associated with=20
the userdata created last in the program. The userdata itself is freed =
only in=20
the next garbage-collection cycle.=20
<H3>2.10.2 - <A name=3D2.10.2>Weak Tables</A></H3>
<P>A <EM>weak table</EM> is a table whose elements are <EM>weak =
references</EM>.=20
A weak reference is ignored by the garbage collector. In other words, if =
the=20
only references to an object are weak references, then the garbage =
collector=20
will collect this object.=20
<P>A weak table can have weak keys, weak values, or both. A table with =
weak keys=20
allows the collection of its keys, but prevents the collection of its =
values. A=20
table with both weak keys and weak values allows the collection of both =
keys and=20
values. In any case, if either the key or the value is collected, the =
whole pair=20
is removed from the table. The weakness of a table is controlled by the=20
<CODE>__mode</CODE> field of its metatable. If the <CODE>__mode</CODE> =
field is=20
a string containing the character&nbsp;'<CODE>k</CODE>', the keys in the =
table=20
are weak. If <CODE>__mode</CODE> contains '<CODE>v</CODE>', the values =
in the=20
table are weak.=20
<P>After you use a table as a metatable, you should not change the value =
of its=20
<CODE>__mode</CODE> field. Otherwise, the weak behavior of the tables =
controlled=20
by this metatable is undefined.=20
<H2>2.11 - <A name=3D2.11>Coroutines</A></H2>
<P>Lua supports coroutines, also called <EM>collaborative =
multithreading</EM>. A=20
coroutine in Lua represents an independent thread of execution. Unlike =
threads=20
in multithread systems, however, a coroutine only suspends its execution =
by=20
explicitly calling a yield function.=20
<P>You create a coroutine with a call to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create"><=
CODE>coroutine.create</CODE></A>.=20
Its sole argument is a function that is the main function of the =
coroutine. The=20
<CODE>create</CODE> function only creates a new coroutine and returns a =
handle=20
to it (an object of type <EM>thread</EM>); it does not start the =
coroutine=20
execution.=20
<P>When you first call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>,=20
passing as its first argument a thread returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create"><=
CODE>coroutine.create</CODE></A>,=20
the coroutine starts its execution, at the first line of its main =
function.=20
Extra arguments passed to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>=20
are passed on to the coroutine main function. After the coroutine starts =

running, it runs until it terminates or <EM>yields</EM>.=20
<P>A coroutine can terminate its execution in two ways: normally, when =
its main=20
function returns (explicitly or implicitly, after the last instruction); =
and=20
abnormally, if there is an unprotected error. In the first case, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>=20
returns <B>true</B>, plus any values returned by the coroutine main =
function. In=20
case of errors, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>=20
returns <B>false</B> plus an error message.=20
<P>A coroutine yields by calling <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield"><C=
ODE>coroutine.yield</CODE></A>.=20
When a coroutine yields, the corresponding <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>=20
returns immediately, even if the yield happens inside nested function =
calls=20
(that is, not in the main function, but in a function directly or =
indirectly=20
called by the main function). In the case of a yield, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>=20
also returns <B>true</B>, plus any values passed to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield"><C=
ODE>coroutine.yield</CODE></A>.=20
The next time you resume the same coroutine, it continues its execution =
from the=20
point where it yielded, with the call to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield"><C=
ODE>coroutine.yield</CODE></A>=20
returning any extra arguments passed to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>.=20

<P>Like <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create"><=
CODE>coroutine.create</CODE></A>,=20
the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap"><CO=
DE>coroutine.wrap</CODE></A>=20
function also creates a coroutine, but instead of returning the =
coroutine=20
itself, it returns a function that, when called, resumes the coroutine. =
Any=20
arguments passed to this function go as extra arguments to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>.=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap"><CO=
DE>coroutine.wrap</CODE></A>=20
returns all the values returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>,=20
except the first one (the boolean error code). Unlike <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume"><=
CODE>coroutine.resume</CODE></A>,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap"><CO=
DE>coroutine.wrap</CODE></A>=20
does not catch errors; any error is propagated to the caller.=20
<P>As an example, consider the following code: <PRE>     function foo =
(a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
    =20
     co =3D coroutine.create(function (a,b)
           print("co-body", a, b)
           local r =3D foo(a+1)
           print("co-body", r)
           local r, s =3D coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
           =20
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</PRE>
<P>When you run it, it produces the following output: <PRE>     co-body =
1       10
     foo     2
    =20
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</PRE>
<P>
<H1>3 - <A name=3D3>The Application Program Interface</A></H1>
<P>This section describes the C&nbsp;API for Lua, that is, the set of=20
C&nbsp;functions available to the host program to communicate with Lua. =
All API=20
functions and related types and constants are declared in the header =
file <A=20
name=3Dpdf-lua.h><CODE>lua.h</CODE></A>.=20
<P>Even when we use the term "function", any facility in the API may be =
provided=20
as a macro instead. All such macros use each of their arguments exactly =
once=20
(except for the first argument, which is always a Lua state), and so do =
not=20
generate any hidden side-effects.=20
<P>As in most C&nbsp;libraries, the Lua API functions do not check their =

arguments for validity or consistency. However, you can change this =
behavior by=20
compiling Lua with a proper definition for the macro <A=20
name=3Dpdf-luai_apicheck><CODE>luai_apicheck</CODE></A>, in file=20
<CODE>luaconf.h</CODE>.=20
<H2>3.1 - <A name=3D3.1>The Stack</A></H2>
<P>Lua uses a <EM>virtual stack</EM> to pass values to and from C. Each =
element=20
in this stack represents a Lua value (<B>nil</B>, number, string, etc.). =

<P>Whenever Lua calls C, the called function gets a new stack, which is=20
independent of previous stacks and of stacks of C&nbsp;functions that =
are still=20
active. This stack initially contains any arguments to the =
C&nbsp;function and=20
it is where the C&nbsp;function pushes its results to be returned to the =
caller=20
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><CODE>lu=
a_CFunction</CODE></A>).=20

<P>For convenience, most query operations in the API do not follow a =
strict=20
stack discipline. Instead, they can refer to any element in the stack by =
using=20
an <EM>index</EM>: A positive index represents an <EM>absolute</EM> =
stack=20
position (starting at&nbsp;1); a negative index represents an =
<EM>offset</EM>=20
relative to the top of the stack. More specifically, if the stack has =
<EM>n</EM>=20
elements, then index&nbsp;1 represents the first element (that is, the =
element=20
that was pushed onto the stack first) and index&nbsp;<EM>n</EM> =
represents the=20
last element; index&nbsp;-1 also represents the last element (that is, =
the=20
element at the&nbsp;top) and index <EM>-n</EM> represents the first =
element. We=20
say that an index is <EM>valid</EM> if it lies between&nbsp;1 and the =
stack top=20
(that is, if <CODE>1 &#8804; abs(index) &#8804; top</CODE>).=20
<H2>3.2 - <A name=3D3.2>Stack Size</A></H2>
<P>When you interact with Lua API, you are responsible for ensuring =
consistency.=20
In particular, <EM>you are responsible for controlling stack =
overflow</EM>. You=20
can use the function <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_checkstack"><CODE>l=
ua_checkstack</CODE></A>=20
to grow the stack size.=20
<P>Whenever Lua calls C, it ensures that at least <A=20
name=3Dpdf-LUA_MINSTACK><CODE>LUA_MINSTACK</CODE></A> stack positions =
are=20
available. <CODE>LUA_MINSTACK</CODE> is defined as 20, so that usually =
you do=20
not have to worry about stack space unless your code has loops pushing =
elements=20
onto the stack.=20
<P>Most query functions accept as indices any value inside the available =
stack=20
space, that is, indices up to the maximum stack size you have set =
through <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_checkstack"><CODE>l=
ua_checkstack</CODE></A>.=20
Such indices are called <EM>acceptable indices</EM>. More formally, we =
define an=20
<EM>acceptable index</EM> as follows: <PRE>     (index &lt; 0 &amp;&amp; =
abs(index) &lt;=3D top) ||
     (index &gt; 0 &amp;&amp; index &lt;=3D stackspace)
</PRE>
<P>Note that 0 is never an acceptable index.=20
<H2>3.3 - <A name=3D3.3>Pseudo-Indices</A></H2>
<P>Unless otherwise noted, any function that accepts valid indices can =
also be=20
called with <EM>pseudo-indices</EM>, which represent some Lua values =
that are=20
accessible to C&nbsp;code but which are not in the stack. Pseudo-indices =
are=20
used to access the thread environment, the function environment, the =
registry,=20
and the upvalues of a C&nbsp;function (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#3.4">=A73.4</A>).=20
<P>The thread environment (where global variables live) is always at=20
pseudo-index <A =
name=3Dpdf-LUA_GLOBALSINDEX><CODE>LUA_GLOBALSINDEX</CODE></A>. The=20
environment of the running C&nbsp;function is always at pseudo-index <A=20
name=3Dpdf-LUA_ENVIRONINDEX><CODE>LUA_ENVIRONINDEX</CODE></A>.=20
<P>To access and change the value of global variables, you can use =
regular table=20
operations over an environment table. For instance, to access the value =
of a=20
global variable, do <PRE>     lua_getfield(L, LUA_GLOBALSINDEX, =
varname);
</PRE>
<H2>3.4 - <A name=3D3.4>C Closures</A></H2>
<P>When a C&nbsp;function is created, it is possible to associate some =
values=20
with it, thus creating a <EM>C&nbsp;closure</EM>; these values are =
called=20
<EM>upvalues</EM> and are accessible to the function whenever it is =
called (see=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pushcclosure"><CODE=
>lua_pushcclosure</CODE></A>).=20

<P>Whenever a C&nbsp;function is called, its upvalues are located at =
specific=20
pseudo-indices. These pseudo-indices are produced by the macro <A=20
name=3Dlua_upvalueindex><CODE>lua_upvalueindex</CODE></A>. The first =
value=20
associated with a function is at position =
<CODE>lua_upvalueindex(1)</CODE>, and=20
so on. Any access to <CODE>lua_upvalueindex(<EM>n</EM>)</CODE>, where =
<EM>n</EM>=20
is greater than the number of upvalues of the current function (but not =
greater=20
than 256), produces an acceptable (but invalid) index.=20
<H2>3.5 - <A name=3D3.5>Registry</A></H2>
<P>Lua provides a <EM>registry</EM>, a pre-defined table that can be =
used by any=20
C&nbsp;code to store whatever Lua value it needs to store. This table is =
always=20
located at pseudo-index <A=20
name=3Dpdf-LUA_REGISTRYINDEX><CODE>LUA_REGISTRYINDEX</CODE></A>. Any=20
C&nbsp;library can store data into this table, but it should take care =
to choose=20
keys different from those used by other libraries, to avoid collisions.=20
Typically, you should use as key a string containing your library name =
or a=20
light userdata with the address of a C&nbsp;object in your code.=20
<P>The integer keys in the registry are used by the reference mechanism, =

implemented by the auxiliary library, and therefore should not be used =
for other=20
purposes.=20
<H2>3.6 - <A name=3D3.6>Error Handling in C</A></H2>
<P>Internally, Lua uses the C <CODE>longjmp</CODE> facility to handle =
errors.=20
(You can also choose to use exceptions if you use C++; see file=20
<CODE>luaconf.h</CODE>.) When Lua faces any error (such as memory =
allocation=20
errors, type errors, syntax errors, and runtime errors) it =
<EM>raises</EM> an=20
error; that is, it does a long jump. A <EM>protected environment</EM> =
uses=20
<CODE>setjmp</CODE> to set a recover point; any error jumps to the most =
recent=20
active recover point.=20
<P>Most functions in the API can throw an error, for instance due to a =
memory=20
allocation error. The documentation for each function indicates whether =
it can=20
throw errors.=20
<P>Inside a C&nbsp;function you can throw an error by calling <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_error"><CODE>lua_er=
ror</CODE></A>.=20

<H2>3.7 - <A name=3D3.7>Functions and Types</A></H2>
<P>Here we list all functions and types from the C&nbsp;API in =
alphabetical=20
order. Each function has an indicator like this: <SPAN class=3Dapii>[-o, =
+p,=20
<EM>x</EM>]</SPAN>=20
<P>The first field, <CODE>o</CODE>, is how many elements the function =
pops from=20
the stack. The second field, <CODE>p</CODE>, is how many elements the =
function=20
pushes onto the stack. (Any function always pushes its results after =
popping its=20
arguments.) A field in the form <CODE>x|y</CODE> means the function can =
push (or=20
pop) <CODE>x</CODE> or <CODE>y</CODE> elements, depending on the =
situation; an=20
interrogation mark '<CODE>?</CODE>' means that we cannot know how many =
elements=20
the function pops/pushes by looking only at its arguments (e.g., they =
may depend=20
on what is on the stack). The third field, <CODE>x</CODE>, tells whether =
the=20
function may throw errors: '<CODE>-</CODE>' means the function never =
throws any=20
error; '<CODE>m</CODE>' means the function may throw an error only due =
to not=20
enough memory; '<CODE>e</CODE>' means the function may throw other kinds =
of=20
errors; '<CODE>v</CODE>' means the function may throw an error on =
purpose.=20
<HR>

<H3><A name=3Dlua_Alloc><CODE>lua_Alloc</CODE></A></H3><PRE>typedef void =
* (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</PRE>
<P>The type of the memory-allocation function used by Lua states. The =
allocator=20
function must provide a functionality similar to <CODE>realloc</CODE>, =
but not=20
exactly the same. Its arguments are <CODE>ud</CODE>, an opaque pointer =
passed to=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newstate"><CODE>lua=
_newstate</CODE></A>;=20
<CODE>ptr</CODE>, a pointer to the block being =
allocated/reallocated/freed;=20
<CODE>osize</CODE>, the original size of the block; <CODE>nsize</CODE>, =
the new=20
size of the block. <CODE>ptr</CODE> is <CODE>NULL</CODE> if and only if=20
<CODE>osize</CODE> is zero. When <CODE>nsize</CODE> is zero, the =
allocator must=20
return <CODE>NULL</CODE>; if <CODE>osize</CODE> is not zero, it should =
free the=20
block pointed to by <CODE>ptr</CODE>. When <CODE>nsize</CODE> is not =
zero, the=20
allocator returns <CODE>NULL</CODE> if and only if it cannot fill the =
request.=20
When <CODE>nsize</CODE> is not zero and <CODE>osize</CODE> is zero, the=20
allocator should behave like <CODE>malloc</CODE>. When =
<CODE>nsize</CODE> and=20
<CODE>osize</CODE> are not zero, the allocator behaves like=20
<CODE>realloc</CODE>. Lua assumes that the allocator never fails when=20
<CODE>osize &gt;=3D nsize</CODE>.=20
<P>Here is a simple implementation for the allocator function. It is =
used in the=20
auxiliary library by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_newstate"><CODE>lu=
aL_newstate</CODE></A>.=20
<PRE>     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize =3D=3D 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</PRE>
<P>This code assumes that <CODE>free(NULL)</CODE> has no effect and that =

<CODE>realloc(NULL, size)</CODE> is equivalent to =
<CODE>malloc(size)</CODE>.=20
ANSI&nbsp;C ensures both behaviors.=20
<HR>

<H3><A name=3Dlua_atpanic><CODE>lua_atpanic</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_CFunction =
lua_atpanic (lua_State *L, lua_CFunction panicf);</PRE>
<P>Sets a new panic function and returns the old one.=20
<P>If an error happens outside any protected environment, Lua calls a =
<EM>panic=20
function</EM> and then calls <CODE>exit(EXIT_FAILURE)</CODE>, thus =
exiting the=20
host application. Your panic function can avoid this exit by never =
returning=20
(e.g., doing a long jump).=20
<P>The panic function can access the error message at the top of the =
stack.=20
<HR>

<H3><A name=3Dlua_call><CODE>lua_call</CODE></A></H3>
<P><SPAN class=3Dapii>[-(nargs + 1), +nresults, <EM>e</EM>]</SPAN> =
<PRE>void lua_call (lua_State *L, int nargs, int nresults);</PRE>
<P>Calls a function.=20
<P>To call a function you must use the following protocol: first, the =
function=20
to be called is pushed onto the stack; then, the arguments to the =
function are=20
pushed in direct order; that is, the first argument is pushed first. =
Finally you=20
call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_call"><CODE>lua_cal=
l</CODE></A>;=20
<CODE>nargs</CODE> is the number of arguments that you pushed onto the =
stack.=20
All arguments and the function value are popped from the stack when the =
function=20
is called. The function results are pushed onto the stack when the =
function=20
returns. The number of results is adjusted to <CODE>nresults</CODE>, =
unless=20
<CODE>nresults</CODE> is <A =
name=3Dpdf-LUA_MULTRET><CODE>LUA_MULTRET</CODE></A>.=20
In this case, <EM>all</EM> results from the function are pushed. Lua =
takes care=20
that the returned values fit into the stack space. The function results =
are=20
pushed onto the stack in direct order (the first result is pushed =
first), so=20
that after the call the last result is on the top of the stack.=20
<P>Any error inside the called function is propagated upwards (with a=20
<CODE>longjmp</CODE>).=20
<P>The following example shows how the host program can do the =
equivalent to=20
this Lua code: <PRE>     a =3D f("how", t.x, 14)
</PRE>
<P>Here it is in&nbsp;C: <PRE>     lua_getfield(L, LUA_GLOBALSINDEX, =
"f"); /* function to be called */
     lua_pushstring(L, "how");                        /* 1st argument */
     lua_getfield(L, LUA_GLOBALSINDEX, "t");   /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setfield(L, LUA_GLOBALSINDEX, "a");        /* set global 'a' */
</PRE>
<P>Note that the code above is "balanced": at its end, the stack is back =
to its=20
original configuration. This is considered good programming practice.=20
<HR>

<H3><A =
name=3Dlua_CFunction><CODE>lua_CFunction</CODE></A></H3><PRE>typedef int =
(*lua_CFunction) (lua_State *L);</PRE>
<P>Type for C&nbsp;functions.=20
<P>In order to communicate properly with Lua, a C&nbsp;function must use =
the=20
following protocol, which defines the way parameters and results are =
passed: a=20
C&nbsp;function receives its arguments from Lua in its stack in direct =
order=20
(the first argument is pushed first). So, when the function starts,=20
<CODE>lua_gettop(L)</CODE> returns the number of arguments received by =
the=20
function. The first argument (if any) is at index 1 and its last =
argument is at=20
index <CODE>lua_gettop(L)</CODE>. To return values to Lua, a =
C&nbsp;function=20
just pushes them onto the stack, in direct order (the first result is =
pushed=20
first), and returns the number of results. Any other value in the stack =
below=20
the results will be properly discarded by Lua. Like a Lua function, a=20
C&nbsp;function called by Lua can also return many results.=20
<P>As an example, the following function receives a variable number of =
numerical=20
arguments and returns their average and sum: <PRE>     static int foo =
(lua_State *L) {
       int n =3D lua_gettop(L);    /* number of arguments */
       lua_Number sum =3D 0;
       int i;
       for (i =3D 1; i &lt;=3D n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "incorrect argument");
           lua_error(L);
         }
         sum +=3D lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</PRE>
<HR>

<H3><A name=3Dlua_checkstack><CODE>lua_checkstack</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>int =
lua_checkstack (lua_State *L, int extra);</PRE>
<P>Ensures that there are at least <CODE>extra</CODE> free stack slots =
in the=20
stack. It returns false if it cannot grow the stack to that size. This =
function=20
never shrinks the stack; if the stack is already larger than the new =
size, it is=20
left unchanged.=20
<HR>

<H3><A name=3Dlua_close><CODE>lua_close</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>void lua_close =
(lua_State *L);</PRE>
<P>Destroys all objects in the given Lua state (calling the =
corresponding=20
garbage-collection metamethods, if any) and frees all dynamic memory =
used by=20
this state. On several platforms, you may not need to call this =
function,=20
because all resources are naturally released when the host program ends. =
On the=20
other hand, long-running programs, such as a daemon or a web server, =
might need=20
to release states as soon as they are not needed, to avoid growing too =
large.=20
<HR>

<H3><A name=3Dlua_concat><CODE>lua_concat</CODE></A></H3>
<P><SPAN class=3Dapii>[-n, +1, <EM>e</EM>]</SPAN> <PRE>void lua_concat =
(lua_State *L, int n);</PRE>
<P>Concatenates the <CODE>n</CODE> values at the top of the stack, pops =
them,=20
and leaves the result at the top. If <CODE>n</CODE>&nbsp;is&nbsp;1, the =
result=20
is the single value on the stack (that is, the function does nothing); =
if=20
<CODE>n</CODE> is 0, the result is the empty string. Concatenation is =
performed=20
following the usual semantics of Lua (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.4">=A72.5.4</A>).=20
<HR>

<H3><A name=3Dlua_cpcall><CODE>lua_cpcall</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +(0|1), <EM>-</EM>]</SPAN> <PRE>int =
lua_cpcall (lua_State *L, lua_CFunction func, void *ud);</PRE>
<P>Calls the C&nbsp;function <CODE>func</CODE> in protected mode.=20
<CODE>func</CODE> starts with only one element in its stack, a light =
userdata=20
containing <CODE>ud</CODE>. In case of errors, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_cpcall"><CODE>lua_c=
pcall</CODE></A>=20
returns the same error codes as <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>,=20
plus the error object on the top of the stack; otherwise, it returns =
zero, and=20
does not change the stack. All values returned by <CODE>func</CODE> are=20
discarded.=20
<HR>

<H3><A name=3Dlua_createtable><CODE>lua_createtable</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void =
lua_createtable (lua_State *L, int narr, int nrec);</PRE>
<P>Creates a new empty table and pushes it onto the stack. The new table =
has=20
space pre-allocated for <CODE>narr</CODE> array elements and =
<CODE>nrec</CODE>=20
non-array elements. This pre-allocation is useful when you know exactly =
how many=20
elements the table will have. Otherwise you can use the function <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newtable"><CODE>lua=
_newtable</CODE></A>.=20

<HR>

<H3><A name=3Dlua_dump><CODE>lua_dump</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>int lua_dump =
(lua_State *L, lua_Writer writer, void *data);</PRE>
<P>Dumps a function as a binary chunk. Receives a Lua function on the =
top of the=20
stack and produces a binary chunk that, if loaded again, results in a =
function=20
equivalent to the one dumped. As it produces parts of the chunk, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_dump"><CODE>lua_dum=
p</CODE></A>=20
calls function <CODE>writer</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Writer"><CODE>lua_W=
riter</CODE></A>)=20
with the given <CODE>data</CODE> to write them.=20
<P>The value returned is the error code returned by the last call to the =
writer;=20
0&nbsp;means no errors.=20
<P>This function does not pop the Lua function from the stack.=20
<HR>

<H3><A name=3Dlua_equal><CODE>lua_equal</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>e</EM>]</SPAN> <PRE>int lua_equal =
(lua_State *L, int index1, int index2);</PRE>
<P>Returns 1 if the two values in acceptable indices <CODE>index1</CODE> =
and=20
<CODE>index2</CODE> are equal, following the semantics of the Lua=20
<CODE>=3D=3D</CODE> operator (that is, may call metamethods). Otherwise=20
returns&nbsp;0. Also returns&nbsp;0 if any of the indices is non valid.=20
<HR>

<H3><A name=3Dlua_error><CODE>lua_error</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>v</EM>]</SPAN> <PRE>int lua_error =
(lua_State *L);</PRE>
<P>Generates a Lua error. The error message (which can actually be a Lua =
value=20
of any type) must be on the stack top. This function does a long jump, =
and=20
therefore never returns. (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_error"><CODE>luaL_=
error</CODE></A>).=20

<HR>

<H3><A name=3Dlua_gc><CODE>lua_gc</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>e</EM>]</SPAN> <PRE>int lua_gc =
(lua_State *L, int what, int data);</PRE>
<P>Controls the garbage collector.=20
<P>This function performs several tasks, according to the value of the =
parameter=20
<CODE>what</CODE>:=20
<UL>
  <LI><B><CODE>LUA_GCSTOP</CODE>:</B> stops the garbage collector.=20
  <LI><B><CODE>LUA_GCRESTART</CODE>:</B> restarts the garbage collector. =

  <LI><B><CODE>LUA_GCCOLLECT</CODE>:</B> performs a full =
garbage-collection=20
  cycle.=20
  <LI><B><CODE>LUA_GCCOUNT</CODE>:</B> returns the current amount of =
memory (in=20
  Kbytes) in use by Lua.=20
  <LI><B><CODE>LUA_GCCOUNTB</CODE>:</B> returns the remainder of =
dividing the=20
  current amount of bytes of memory in use by Lua by 1024.=20
  <LI><B><CODE>LUA_GCSTEP</CODE>:</B> performs an incremental step of =
garbage=20
  collection. The step "size" is controlled by <CODE>data</CODE> (larger =
values=20
  mean more steps) in a non-specified way. If you want to control the =
step size=20
  you must experimentally tune the value of <CODE>data</CODE>. The =
function=20
  returns 1 if the step finished a garbage-collection cycle.=20
  <LI><B><CODE>LUA_GCSETPAUSE</CODE>:</B> sets <CODE>data</CODE> as the =
new=20
  value for the <EM>pause</EM> of the collector (see <A=20
  href=3D"http://www.lua.org/manual/5.1/manual.html#2.10">=A72.10</A>). =
The function=20
  returns the previous value of the pause.=20
  <LI><B><CODE>LUA_GCSETSTEPMUL</CODE>:</B> sets <CODE>data</CODE> as =
the new=20
  value for the <EM>step multiplier</EM> of the collector (see <A=20
  href=3D"http://www.lua.org/manual/5.1/manual.html#2.10">=A72.10</A>). =
The function=20
  returns the previous value of the step multiplier. </LI></UL>
<HR>

<H3><A name=3Dlua_getallocf><CODE>lua_getallocf</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_Alloc =
lua_getallocf (lua_State *L, void **ud);</PRE>
<P>Returns the memory-allocation function of a given state. If =
<CODE>ud</CODE>=20
is not <CODE>NULL</CODE>, Lua stores in <CODE>*ud</CODE> the opaque =
pointer=20
passed to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newstate"><CODE>lua=
_newstate</CODE></A>.=20

<HR>

<H3><A name=3Dlua_getfenv><CODE>lua_getfenv</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void lua_getfenv =
(lua_State *L, int index);</PRE>
<P>Pushes onto the stack the environment table of the value at the given =
index.=20
<HR>

<H3><A name=3Dlua_getfield><CODE>lua_getfield</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>e</EM>]</SPAN> <PRE>void lua_getfield =
(lua_State *L, int index, const char *k);</PRE>
<P>Pushes onto the stack the value <CODE>t[k]</CODE>, where =
<CODE>t</CODE> is=20
the value at the given valid index. As in Lua, this function may trigger =
a=20
metamethod for the "index" event (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<HR>

<H3><A name=3Dlua_getglobal><CODE>lua_getglobal</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>e</EM>]</SPAN> <PRE>void =
lua_getglobal (lua_State *L, const char *name);</PRE>
<P>Pushes onto the stack the value of the global <CODE>name</CODE>. It =
is=20
defined as a macro: <PRE>     #define lua_getglobal(L,s)  =
lua_getfield(L, LUA_GLOBALSINDEX, s)
</PRE>
<HR>

<H3><A name=3Dlua_getmetatable><CODE>lua_getmetatable</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +(0|1), <EM>-</EM>]</SPAN> <PRE>int =
lua_getmetatable (lua_State *L, int index);</PRE>
<P>Pushes onto the stack the metatable of the value at the given =
acceptable=20
index. If the index is not valid, or if the value does not have a =
metatable, the=20
function returns&nbsp;0 and pushes nothing on the stack.=20
<HR>

<H3><A name=3Dlua_gettable><CODE>lua_gettable</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +1, <EM>e</EM>]</SPAN> <PRE>void lua_gettable =
(lua_State *L, int index);</PRE>
<P>Pushes onto the stack the value <CODE>t[k]</CODE>, where =
<CODE>t</CODE> is=20
the value at the given valid index and <CODE>k</CODE> is the value at =
the top of=20
the stack.=20
<P>This function pops the key from the stack (putting the resulting =
value in its=20
place). As in Lua, this function may trigger a metamethod for the =
"index" event=20
(see <A =
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<HR>

<H3><A name=3Dlua_gettop><CODE>lua_gettop</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_gettop =
(lua_State *L);</PRE>
<P>Returns the index of the top element in the stack. Because indices =
start=20
at&nbsp;1, this result is equal to the number of elements in the stack =
(and so=20
0&nbsp;means an empty stack).=20
<HR>

<H3><A name=3Dlua_insert><CODE>lua_insert</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +1, <EM>-</EM>]</SPAN> <PRE>void lua_insert =
(lua_State *L, int index);</PRE>
<P>Moves the top element into the given valid index, shifting up the =
elements=20
above this index to open space. Cannot be called with a pseudo-index, =
because a=20
pseudo-index is not an actual stack position.=20
<HR>

<H3><A name=3Dlua_Integer><CODE>lua_Integer</CODE></A></H3><PRE>typedef =
ptrdiff_t lua_Integer;</PRE>
<P>The type used by the Lua API to represent integral values.=20
<P>By default it is a <CODE>ptrdiff_t</CODE>, which is usually the =
largest=20
signed integral type the machine handles "comfortably".=20
<HR>

<H3><A name=3Dlua_isboolean><CODE>lua_isboolean</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_isboolean =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index has type =
boolean, and=20
0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_iscfunction><CODE>lua_iscfunction</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_iscfunction (lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a =
C&nbsp;function,=20
and 0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isfunction><CODE>lua_isfunction</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_isfunction (lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a function =
(either C=20
or Lua), and 0&nbsp;otherwise.=20
<HR>

<H3><A =
name=3Dlua_islightuserdata><CODE>lua_islightuserdata</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_islightuserdata (lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a light =
userdata, and=20
0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isnil><CODE>lua_isnil</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_isnil =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is <B>nil</B>, =
and=20
0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isnone><CODE>lua_isnone</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_isnone =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the given acceptable index is not valid (that is, it =
refers to=20
an element outside the current stack), and 0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isnoneornil><CODE>lua_isnoneornil</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_isnoneornil (lua_State *L, int index);</PRE>
<P>Returns 1 if the given acceptable index is not valid (that is, it =
refers to=20
an element outside the current stack) or if the value at this index is=20
<B>nil</B>, and 0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isnumber><CODE>lua_isnumber</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_isnumber =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a number or a =
string=20
convertible to a number, and 0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isstring><CODE>lua_isstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_isstring =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a string or a =
number=20
(which is always convertible to a string), and 0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_istable><CODE>lua_istable</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_istable =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a table, and=20
0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isthread><CODE>lua_isthread</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_isthread =
(lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a thread, and =

0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_isuserdata><CODE>lua_isuserdata</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_isuserdata (lua_State *L, int index);</PRE>
<P>Returns 1 if the value at the given acceptable index is a userdata =
(either=20
full or light), and 0&nbsp;otherwise.=20
<HR>

<H3><A name=3Dlua_lessthan><CODE>lua_lessthan</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>e</EM>]</SPAN> <PRE>int lua_lessthan =
(lua_State *L, int index1, int index2);</PRE>
<P>Returns 1 if the value at acceptable index <CODE>index1</CODE> is =
smaller=20
than the value at acceptable index <CODE>index2</CODE>, following the =
semantics=20
of the Lua <CODE>&lt;</CODE> operator (that is, may call metamethods). =
Otherwise=20
returns&nbsp;0. Also returns&nbsp;0 if any of the indices is non valid.=20
<HR>

<H3><A name=3Dlua_load><CODE>lua_load</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>int lua_load =
(lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname);</PRE>
<P>Loads a Lua chunk. If there are no errors, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
pushes the compiled chunk as a Lua function on top of the stack. =
Otherwise, it=20
pushes an error message. The return values of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
are:=20
<UL>
  <LI><B>0:</B> no errors;=20
  <LI><B><A name=3Dpdf-LUA_ERRSYNTAX><CODE>LUA_ERRSYNTAX</CODE></A>:</B> =
syntax=20
  error during pre-compilation;=20
  <LI><B><A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-LUA_ERRMEM"><CODE>L=
UA_ERRMEM</CODE></A>:</B>=20
  memory allocation error. </LI></UL>
<P>This function only loads a chunk; it does not run it.=20
<P><A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
automatically detects whether the chunk is text or binary, and loads it=20
accordingly (see program <CODE>luac</CODE>).=20
<P>The <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
function uses a user-supplied <CODE>reader</CODE> function to read the =
chunk=20
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Reader"><CODE>lua_R=
eader</CODE></A>).=20
The <CODE>data</CODE> argument is an opaque value passed to the reader =
function.=20

<P>The <CODE>chunkname</CODE> argument gives a name to the chunk, which =
is used=20
for error messages and in debug information (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#3.8">=A73.8</A>).=20
<HR>

<H3><A name=3Dlua_newstate><CODE>lua_newstate</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_State =
*lua_newstate (lua_Alloc f, void *ud);</PRE>
<P>Creates a new, independent state. Returns <CODE>NULL</CODE> if cannot =
create=20
the state (due to lack of memory). The argument <CODE>f</CODE> is the =
allocator=20
function; Lua does all memory allocation for this state through this =
function.=20
The second argument, <CODE>ud</CODE>, is an opaque pointer that Lua =
simply=20
passes to the allocator in every call.=20
<HR>

<H3><A name=3Dlua_newtable><CODE>lua_newtable</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void lua_newtable =
(lua_State *L);</PRE>
<P>Creates a new empty table and pushes it onto the stack. It is =
equivalent to=20
<CODE>lua_createtable(L, 0, 0)</CODE>.=20
<HR>

<H3><A name=3Dlua_newthread><CODE>lua_newthread</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>lua_State =
*lua_newthread (lua_State *L);</PRE>
<P>Creates a new thread, pushes it on the stack, and returns a pointer =
to a <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_State"><CODE>lua_St=
ate</CODE></A>=20
that represents this new thread. The new state returned by this function =
shares=20
with the original state all global objects (such as tables), but has an=20
independent execution stack.=20
<P>There is no explicit function to close or to destroy a thread. =
Threads are=20
subject to garbage collection, like any Lua object.=20
<HR>

<H3><A name=3Dlua_newuserdata><CODE>lua_newuserdata</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void =
*lua_newuserdata (lua_State *L, size_t size);</PRE>
<P>This function allocates a new block of memory with the given size, =
pushes=20
onto the stack a new full userdata with the block address, and returns =
this=20
address.=20
<P>Userdata represent C&nbsp;values in Lua. A <EM>full userdata</EM> =
represents=20
a block of memory. It is an object (like a table): you must create it, =
it can=20
have its own metatable, and you can detect when it is being collected. A =
full=20
userdata is only equal to itself (under raw equality).=20
<P>When Lua collects a full userdata with a <CODE>gc</CODE> metamethod, =
Lua=20
calls the metamethod and marks the userdata as finalized. When this =
userdata is=20
collected again then Lua frees its corresponding memory.=20
<HR>

<H3><A name=3Dlua_next><CODE>lua_next</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +(2|0), <EM>e</EM>]</SPAN> <PRE>int lua_next =
(lua_State *L, int index);</PRE>
<P>Pops a key from the stack, and pushes a key-value pair from the table =
at the=20
given index (the "next" pair after the given key). If there are no more =
elements=20
in the table, then <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_next"><CODE>lua_nex=
t</CODE></A>=20
returns 0 (and pushes nothing).=20
<P>A typical traversal looks like this: <PRE>     /* table is in the =
stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) !=3D 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</PRE>
<P>While traversing a table, do not call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
directly on a key, unless you know that the key is actually a string. =
Recall=20
that <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
<EM>changes</EM> the value at the given index; this confuses the next =
call to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_next"><CODE>lua_nex=
t</CODE></A>.=20

<HR>

<H3><A name=3Dlua_Number><CODE>lua_Number</CODE></A></H3><PRE>typedef =
double lua_Number;</PRE>
<P>The type of numbers in Lua. By default, it is double, but that can be =
changed=20
in <CODE>luaconf.h</CODE>.=20
<P>Through the configuration file you can change Lua to operate with =
another=20
type for numbers (e.g., float or long).=20
<HR>

<H3><A name=3Dlua_objlen><CODE>lua_objlen</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>size_t lua_objlen =
(lua_State *L, int index);</PRE>
<P>Returns the "length" of the value at the given acceptable index: for =
strings,=20
this is the string length; for tables, this is the result of the length =
operator=20
('<CODE>#</CODE>'); for userdata, this is the size of the block of =
memory=20
allocated for the userdata; for other values, it is&nbsp;0.=20
<HR>

<H3><A name=3Dlua_pcall><CODE>lua_pcall</CODE></A></H3>
<P><SPAN class=3Dapii>[-(nargs + 1), +(nresults|1), <EM>-</EM>]</SPAN> =
<PRE>int lua_pcall (lua_State *L, int nargs, int nresults, int =
errfunc);</PRE>
<P>Calls a function in protected mode.=20
<P>Both <CODE>nargs</CODE> and <CODE>nresults</CODE> have the same =
meaning as in=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_call"><CODE>lua_cal=
l</CODE></A>.=20
If there are no errors during the call, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>=20
behaves exactly like <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_call"><CODE>lua_cal=
l</CODE></A>.=20
However, if there is any error, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>=20
catches it, pushes a single value on the stack (the error message), and =
returns=20
an error code. Like <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_call"><CODE>lua_cal=
l</CODE></A>,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>=20
always removes the function and its arguments from the stack.=20
<P>If <CODE>errfunc</CODE> is 0, then the error message returned on the =
stack is=20
exactly the original error message. Otherwise, <CODE>errfunc</CODE> is =
the stack=20
index of an <EM>error handler function</EM>. (In the current =
implementation,=20
this index cannot be a pseudo-index.) In case of runtime errors, this =
function=20
will be called with the error message and its return value will be the =
message=20
returned on the stack by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>.=20

<P>Typically, the error handler function is used to add more debug =
information=20
to the error message, such as a stack traceback. Such information cannot =
be=20
gathered after the return of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>,=20
since by then the stack has unwound.=20
<P>The <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>=20
function returns 0 in case of success or one of the following error =
codes=20
(defined in <CODE>lua.h</CODE>):=20
<UL>
  <LI><B><A name=3Dpdf-LUA_ERRRUN><CODE>LUA_ERRRUN</CODE></A>:</B> a =
runtime=20
  error.=20
  <LI><B><A name=3Dpdf-LUA_ERRMEM><CODE>LUA_ERRMEM</CODE></A>:</B> =
memory=20
  allocation error. For such errors, Lua does not call the error handler =

  function.=20
  <LI><B><A name=3Dpdf-LUA_ERRERR><CODE>LUA_ERRERR</CODE></A>:</B> error =
while=20
  running the error handler function. </LI></UL>
<HR>

<H3><A name=3Dlua_pop><CODE>lua_pop</CODE></A></H3>
<P><SPAN class=3Dapii>[-n, +0, <EM>-</EM>]</SPAN> <PRE>void lua_pop =
(lua_State *L, int n);</PRE>
<P>Pops <CODE>n</CODE> elements from the stack.=20
<HR>

<H3><A name=3Dlua_pushboolean><CODE>lua_pushboolean</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void =
lua_pushboolean (lua_State *L, int b);</PRE>
<P>Pushes a boolean value with value <CODE>b</CODE> onto the stack.=20
<HR>

<H3><A name=3Dlua_pushcclosure><CODE>lua_pushcclosure</CODE></A></H3>
<P><SPAN class=3Dapii>[-n, +1, <EM>m</EM>]</SPAN> <PRE>void =
lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</PRE>
<P>Pushes a new C&nbsp;closure onto the stack.=20
<P>When a C&nbsp;function is created, it is possible to associate some =
values=20
with it, thus creating a C&nbsp;closure (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#3.4">=A73.4</A>); =
these values are=20
then accessible to the function whenever it is called. To associate =
values with=20
a C&nbsp;function, first these values should be pushed onto the stack =
(when=20
there are multiple values, the first value is pushed first). Then <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pushcclosure"><CODE=
>lua_pushcclosure</CODE></A>=20
is called to create and push the C&nbsp;function onto the stack, with =
the=20
argument <CODE>n</CODE> telling how many values should be associated =
with the=20
function. <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pushcclosure"><CODE=
>lua_pushcclosure</CODE></A>=20
also pops these values from the stack.=20
<P>The maximum value for <CODE>n</CODE> is 255.=20
<HR>

<H3><A name=3Dlua_pushcfunction><CODE>lua_pushcfunction</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void =
lua_pushcfunction (lua_State *L, lua_CFunction f);</PRE>
<P>Pushes a C&nbsp;function onto the stack. This function receives a =
pointer to=20
a C function and pushes onto the stack a Lua value of type =
<CODE>function</CODE>=20
that, when called, invokes the corresponding C&nbsp;function.=20
<P>Any function to be registered in Lua must follow the correct protocol =
to=20
receive its parameters and return its results (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><CODE>lu=
a_CFunction</CODE></A>).=20

<P><CODE>lua_pushcfunction</CODE> is defined as a macro: <PRE>     =
#define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</PRE>
<HR>

<H3><A name=3Dlua_pushfstring><CODE>lua_pushfstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>const char =
*lua_pushfstring (lua_State *L, const char *fmt, ...);</PRE>
<P>Pushes onto the stack a formatted string and returns a pointer to =
this=20
string. It is similar to the C&nbsp;function <CODE>sprintf</CODE>, but =
has some=20
important differences:=20
<UL>
  <LI>You do not have to allocate space for the result: the result is a =
Lua=20
  string and Lua takes care of memory allocation (and deallocation, =
through=20
  garbage collection).=20
  <LI>The conversion specifiers are quite restricted. There are no =
flags,=20
  widths, or precisions. The conversion specifiers can only be =
'<CODE>%%</CODE>'=20
  (inserts a '<CODE>%</CODE>' in the string), '<CODE>%s</CODE>' (inserts =
a=20
  zero-terminated string, with no size restrictions), '<CODE>%f</CODE>' =
(inserts=20
  a <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Number"><CODE>lua_N=
umber</CODE></A>),=20
  '<CODE>%p</CODE>' (inserts a pointer as a hexadecimal numeral),=20
  '<CODE>%d</CODE>' (inserts an <CODE>int</CODE>), and '<CODE>%c</CODE>' =

  (inserts an <CODE>int</CODE> as a character). </LI></UL>
<HR>

<H3><A name=3Dlua_pushinteger><CODE>lua_pushinteger</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void =
lua_pushinteger (lua_State *L, lua_Integer n);</PRE>
<P>Pushes a number with value <CODE>n</CODE> onto the stack.=20
<HR>

<H3><A =
name=3Dlua_pushlightuserdata><CODE>lua_pushlightuserdata</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void =
lua_pushlightuserdata (lua_State *L, void *p);</PRE>
<P>Pushes a light userdata onto the stack.=20
<P>Userdata represent C&nbsp;values in Lua. A <EM>light userdata</EM> =
represents=20
a pointer. It is a value (like a number): you do not create it, it has =
no=20
individual metatable, and it is not collected (as it was never created). =
A light=20
userdata is equal to "any" light userdata with the same C&nbsp;address.=20
<HR>

<H3><A name=3Dlua_pushliteral><CODE>lua_pushliteral</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void =
lua_pushliteral (lua_State *L, const char *s);</PRE>
<P>This macro is equivalent to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pushlstring"><CODE>=
lua_pushlstring</CODE></A>,=20
but can be used only when <CODE>s</CODE> is a literal string. In these =
cases, it=20
automatically provides the string length.=20
<HR>

<H3><A name=3Dlua_pushlstring><CODE>lua_pushlstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void =
lua_pushlstring (lua_State *L, const char *s, size_t len);</PRE>
<P>Pushes the string pointed to by <CODE>s</CODE> with size =
<CODE>len</CODE>=20
onto the stack. Lua makes (or reuses) an internal copy of the given =
string, so=20
the memory at <CODE>s</CODE> can be freed or reused immediately after =
the=20
function returns. The string can contain embedded zeros.=20
<HR>

<H3><A name=3Dlua_pushnil><CODE>lua_pushnil</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void lua_pushnil =
(lua_State *L);</PRE>
<P>Pushes a nil value onto the stack.=20
<HR>

<H3><A name=3Dlua_pushnumber><CODE>lua_pushnumber</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void =
lua_pushnumber (lua_State *L, lua_Number n);</PRE>
<P>Pushes a number with value <CODE>n</CODE> onto the stack.=20
<HR>

<H3><A name=3Dlua_pushstring><CODE>lua_pushstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void =
lua_pushstring (lua_State *L, const char *s);</PRE>
<P>Pushes the zero-terminated string pointed to by <CODE>s</CODE> onto =
the=20
stack. Lua makes (or reuses) an internal copy of the given string, so =
the memory=20
at <CODE>s</CODE> can be freed or reused immediately after the function =
returns.=20
The string cannot contain embedded zeros; it is assumed to end at the =
first=20
zero.=20
<HR>

<H3><A name=3Dlua_pushthread><CODE>lua_pushthread</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>int =
lua_pushthread (lua_State *L);</PRE>
<P>Pushes the thread represented by <CODE>L</CODE> onto the stack. =
Returns 1 if=20
this thread is the main thread of its state.=20
<HR>

<H3><A name=3Dlua_pushvalue><CODE>lua_pushvalue</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void =
lua_pushvalue (lua_State *L, int index);</PRE>
<P>Pushes a copy of the element at the given valid index onto the stack. =

<HR>

<H3><A name=3Dlua_pushvfstring><CODE>lua_pushvfstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>const char =
*lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</PRE>
<P>Equivalent to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pushfstring"><CODE>=
lua_pushfstring</CODE></A>,=20
except that it receives a <CODE>va_list</CODE> instead of a variable =
number of=20
arguments.=20
<HR>

<H3><A name=3Dlua_rawequal><CODE>lua_rawequal</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_rawequal =
(lua_State *L, int index1, int index2);</PRE>
<P>Returns 1 if the two values in acceptable indices <CODE>index1</CODE> =
and=20
<CODE>index2</CODE> are primitively equal (that is, without calling=20
metamethods). Otherwise returns&nbsp;0. Also returns&nbsp;0 if any of =
the=20
indices are non valid.=20
<HR>

<H3><A name=3Dlua_rawget><CODE>lua_rawget</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +1, <EM>-</EM>]</SPAN> <PRE>void lua_rawget =
(lua_State *L, int index);</PRE>
<P>Similar to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_gettable"><CODE>lua=
_gettable</CODE></A>,=20
but does a raw access (i.e., without metamethods).=20
<HR>

<H3><A name=3Dlua_rawgeti><CODE>lua_rawgeti</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void lua_rawgeti =
(lua_State *L, int index, int n);</PRE>
<P>Pushes onto the stack the value <CODE>t[n]</CODE>, where =
<CODE>t</CODE> is=20
the value at the given valid index. The access is raw; that is, it does =
not=20
invoke metamethods.=20
<HR>

<H3><A name=3Dlua_rawset><CODE>lua_rawset</CODE></A></H3>
<P><SPAN class=3Dapii>[-2, +0, <EM>m</EM>]</SPAN> <PRE>void lua_rawset =
(lua_State *L, int index);</PRE>
<P>Similar to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_settable"><CODE>lua=
_settable</CODE></A>,=20
but does a raw assignment (i.e., without metamethods).=20
<HR>

<H3><A name=3Dlua_rawseti><CODE>lua_rawseti</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>m</EM>]</SPAN> <PRE>void lua_rawseti =
(lua_State *L, int index, int n);</PRE>
<P>Does the equivalent of <CODE>t[n] =3D v</CODE>, where <CODE>t</CODE> =
is the=20
value at the given valid index and <CODE>v</CODE> is the value at the =
top of the=20
stack.=20
<P>This function pops the value from the stack. The assignment is raw; =
that is,=20
it does not invoke metamethods.=20
<HR>

<H3><A name=3Dlua_Reader><CODE>lua_Reader</CODE></A></H3><PRE>typedef =
const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</PRE>
<P>The reader function used by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>.=20
Every time it needs another piece of the chunk, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
calls the reader, passing along its <CODE>data</CODE> parameter. The =
reader must=20
return a pointer to a block of memory with a new piece of the chunk and =
set=20
<CODE>size</CODE> to the block size. The block must exist until the =
reader=20
function is called again. To signal the end of the chunk, the reader =
must return=20
<CODE>NULL</CODE> or set <CODE>size</CODE> to zero. The reader function =
may=20
return pieces of any size greater than zero.=20
<HR>

<H3><A name=3Dlua_register><CODE>lua_register</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>e</EM>]</SPAN> <PRE>void lua_register =
(lua_State *L,
                   const char *name,
                   lua_CFunction f);</PRE>
<P>Sets the C function <CODE>f</CODE> as the new value of global=20
<CODE>name</CODE>. It is defined as a macro: <PRE>     #define =
lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</PRE>
<HR>

<H3><A name=3Dlua_remove><CODE>lua_remove</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>-</EM>]</SPAN> <PRE>void lua_remove =
(lua_State *L, int index);</PRE>
<P>Removes the element at the given valid index, shifting down the =
elements=20
above this index to fill the gap. Cannot be called with a pseudo-index, =
because=20
a pseudo-index is not an actual stack position.=20
<HR>

<H3><A name=3Dlua_replace><CODE>lua_replace</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>-</EM>]</SPAN> <PRE>void lua_replace =
(lua_State *L, int index);</PRE>
<P>Moves the top element into the given position (and pops it), without =
shifting=20
any element (therefore replacing the value at the given position).=20
<HR>

<H3><A name=3Dlua_resume><CODE>lua_resume</CODE></A></H3>
<P><SPAN class=3Dapii>[-?, +?, <EM>-</EM>]</SPAN> <PRE>int lua_resume =
(lua_State *L, int narg);</PRE>
<P>Starts and resumes a coroutine in a given thread.=20
<P>To start a coroutine, you first create a new thread (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newthread"><CODE>lu=
a_newthread</CODE></A>);=20
then you push onto its stack the main function plus any arguments; then =
you call=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_resume"><CODE>lua_r=
esume</CODE></A>,=20
with <CODE>narg</CODE> being the number of arguments. This call returns =
when the=20
coroutine suspends or finishes its execution. When it returns, the stack =

contains all values passed to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_yield"><CODE>lua_yi=
eld</CODE></A>,=20
or all values returned by the body function. <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_resume"><CODE>lua_r=
esume</CODE></A>=20
returns <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-LUA_YIELD"><CODE>LU=
A_YIELD</CODE></A>=20
if the coroutine yields, 0 if the coroutine finishes its execution =
without=20
errors, or an error code in case of errors (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pcall"><CODE>lua_pc=
all</CODE></A>).=20
In case of errors, the stack is not unwound, so you can use the debug =
API over=20
it. The error message is on the top of the stack. To restart a =
coroutine, you=20
put on its stack only the values to be passed as results from=20
<CODE>yield</CODE>, and then call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_resume"><CODE>lua_r=
esume</CODE></A>.=20

<HR>

<H3><A name=3Dlua_setallocf><CODE>lua_setallocf</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>void =
lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</PRE>
<P>Changes the allocator function of a given state to <CODE>f</CODE> =
with user=20
data <CODE>ud</CODE>.=20
<HR>

<H3><A name=3Dlua_setfenv><CODE>lua_setfenv</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>-</EM>]</SPAN> <PRE>int lua_setfenv =
(lua_State *L, int index);</PRE>
<P>Pops a table from the stack and sets it as the new environment for =
the value=20
at the given index. If the value at the given index is neither a =
function nor a=20
thread nor a userdata, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_setfenv"><CODE>lua_=
setfenv</CODE></A>=20
returns 0. Otherwise it returns 1.=20
<HR>

<H3><A name=3Dlua_setfield><CODE>lua_setfield</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>e</EM>]</SPAN> <PRE>void lua_setfield =
(lua_State *L, int index, const char *k);</PRE>
<P>Does the equivalent to <CODE>t[k] =3D v</CODE>, where <CODE>t</CODE> =
is the=20
value at the given valid index and <CODE>v</CODE> is the value at the =
top of the=20
stack.=20
<P>This function pops the value from the stack. As in Lua, this function =
may=20
trigger a metamethod for the "newindex" event (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<HR>

<H3><A name=3Dlua_setglobal><CODE>lua_setglobal</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>e</EM>]</SPAN> <PRE>void =
lua_setglobal (lua_State *L, const char *name);</PRE>
<P>Pops a value from the stack and sets it as the new value of global=20
<CODE>name</CODE>. It is defined as a macro: <PRE>     #define =
lua_setglobal(L,s)   lua_setfield(L, LUA_GLOBALSINDEX, s)
</PRE>
<HR>

<H3><A name=3Dlua_setmetatable><CODE>lua_setmetatable</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_setmetatable (lua_State *L, int index);</PRE>
<P>Pops a table from the stack and sets it as the new metatable for the =
value at=20
the given acceptable index.=20
<HR>

<H3><A name=3Dlua_settable><CODE>lua_settable</CODE></A></H3>
<P><SPAN class=3Dapii>[-2, +0, <EM>e</EM>]</SPAN> <PRE>void lua_settable =
(lua_State *L, int index);</PRE>
<P>Does the equivalent to <CODE>t[k] =3D v</CODE>, where <CODE>t</CODE> =
is the=20
value at the given valid index, <CODE>v</CODE> is the value at the top =
of the=20
stack, and <CODE>k</CODE> is the value just below the top.=20
<P>This function pops both the key and the value from the stack. As in =
Lua, this=20
function may trigger a metamethod for the "newindex" event (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.8">=A72.8</A>).=20
<HR>

<H3><A name=3Dlua_settop><CODE>lua_settop</CODE></A></H3>
<P><SPAN class=3Dapii>[-?, +?, <EM>-</EM>]</SPAN> <PRE>void lua_settop =
(lua_State *L, int index);</PRE>
<P>Accepts any acceptable index, or&nbsp;0, and sets the stack top to =
this=20
index. If the new top is larger than the old one, then the new elements =
are=20
filled with <B>nil</B>. If <CODE>index</CODE> is&nbsp;0, then all stack =
elements=20
are removed.=20
<HR>

<H3><A name=3Dlua_State><CODE>lua_State</CODE></A></H3><PRE>typedef =
struct lua_State lua_State;</PRE>
<P>Opaque structure that keeps the whole state of a Lua interpreter. The =
Lua=20
library is fully reentrant: it has no global variables. All information =
about a=20
state is kept in this structure.=20
<P>A pointer to this state must be passed as the first argument to every =

function in the library, except to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newstate"><CODE>lua=
_newstate</CODE></A>,=20
which creates a Lua state from scratch.=20
<HR>

<H3><A name=3Dlua_status><CODE>lua_status</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_status =
(lua_State *L);</PRE>
<P>Returns the status of the thread <CODE>L</CODE>.=20
<P>The status can be 0 for a normal thread, an error code if the thread =
finished=20
its execution with an error, or <A =
name=3Dpdf-LUA_YIELD><CODE>LUA_YIELD</CODE></A>=20
if the thread is suspended.=20
<HR>

<H3><A name=3Dlua_toboolean><CODE>lua_toboolean</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_toboolean =
(lua_State *L, int index);</PRE>
<P>Converts the Lua value at the given acceptable index to a =
C&nbsp;boolean=20
value (0&nbsp;or&nbsp;1). Like all tests in Lua, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_toboolean"><CODE>lu=
a_toboolean</CODE></A>=20
returns 1 for any Lua value different from <B>false</B> and <B>nil</B>;=20
otherwise it returns 0. It also returns 0 when called with a non-valid =
index.=20
(If you want to accept only actual boolean values, use <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_isboolean"><CODE>lu=
a_isboolean</CODE></A>=20
to test the value's type.)=20
<HR>

<H3><A name=3Dlua_tocfunction><CODE>lua_tocfunction</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_CFunction =
lua_tocfunction (lua_State *L, int index);</PRE>
<P>Converts a value at the given acceptable index to a C&nbsp;function. =
That=20
value must be a C&nbsp;function; otherwise, returns <CODE>NULL</CODE>.=20
<HR>

<H3><A name=3Dlua_tointeger><CODE>lua_tointeger</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_Integer =
lua_tointeger (lua_State *L, int index);</PRE>
<P>Converts the Lua value at the given acceptable index to the signed =
integral=20
type <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Integer"><CODE>lua_=
Integer</CODE></A>.=20
The Lua value must be a number or a string convertible to a number (see =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.2.1">=A72.2.1</A>); =
otherwise,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tointeger"><CODE>lu=
a_tointeger</CODE></A>=20
returns&nbsp;0.=20
<P>If the number is not an integer, it is truncated in some =
non-specified way.=20
<HR>

<H3><A name=3Dlua_tolstring><CODE>lua_tolstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>const char =
*lua_tolstring (lua_State *L, int index, size_t *len);</PRE>
<P>Converts the Lua value at the given acceptable index to a =
C&nbsp;string. If=20
<CODE>len</CODE> is not <CODE>NULL</CODE>, it also sets =
<CODE>*len</CODE> with=20
the string length. The Lua value must be a string or a number; =
otherwise, the=20
function returns <CODE>NULL</CODE>. If the value is a number, then <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
also <EM>changes the actual value in the stack to a string</EM>. (This =
change=20
confuses <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_next"><CODE>lua_nex=
t</CODE></A>=20
when <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
is applied to keys during a table traversal.)=20
<P><A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
returns a fully aligned pointer to a string inside the Lua state. This =
string=20
always has a zero ('<CODE>\0</CODE>') after its last character (as =
in&nbsp;C),=20
but can contain other zeros in its body. Because Lua has garbage =
collection,=20
there is no guarantee that the pointer returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
will be valid after the corresponding value is removed from the stack.=20
<HR>

<H3><A name=3Dlua_tonumber><CODE>lua_tonumber</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_Number =
lua_tonumber (lua_State *L, int index);</PRE>
<P>Converts the Lua value at the given acceptable index to the =
C&nbsp;type <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Number"><CODE>lua_N=
umber</CODE></A>=20
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Number"><CODE>lua_N=
umber</CODE></A>).=20
The Lua value must be a number or a string convertible to a number (see =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.2.1">=A72.2.1</A>); =
otherwise,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tonumber"><CODE>lua=
_tonumber</CODE></A>=20
returns&nbsp;0.=20
<HR>

<H3><A name=3Dlua_topointer><CODE>lua_topointer</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>const void =
*lua_topointer (lua_State *L, int index);</PRE>
<P>Converts the value at the given acceptable index to a generic =
C&nbsp;pointer=20
(<CODE>void*</CODE>). The value can be a userdata, a table, a thread, or =
a=20
function; otherwise, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_topointer"><CODE>lu=
a_topointer</CODE></A>=20
returns <CODE>NULL</CODE>. Different objects will give different =
pointers. There=20
is no way to convert the pointer back to its original value.=20
<P>Typically this function is used only for debug information.=20
<HR>

<H3><A name=3Dlua_tostring><CODE>lua_tostring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>const char =
*lua_tostring (lua_State *L, int index);</PRE>
<P>Equivalent to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
with <CODE>len</CODE> equal to <CODE>NULL</CODE>.=20
<HR>

<H3><A name=3Dlua_tothread><CODE>lua_tothread</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_State =
*lua_tothread (lua_State *L, int index);</PRE>
<P>Converts the value at the given acceptable index to a Lua thread =
(represented=20
as <CODE>lua_State*</CODE>). This value must be a thread; otherwise, the =

function returns <CODE>NULL</CODE>.=20
<HR>

<H3><A name=3Dlua_touserdata><CODE>lua_touserdata</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>void =
*lua_touserdata (lua_State *L, int index);</PRE>
<P>If the value at the given acceptable index is a full userdata, =
returns its=20
block address. If the value is a light userdata, returns its pointer. =
Otherwise,=20
returns <CODE>NULL</CODE>.=20
<HR>

<H3><A name=3Dlua_type><CODE>lua_type</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_type =
(lua_State *L, int index);</PRE>
<P>Returns the type of the value in the given acceptable index, or=20
<CODE>LUA_TNONE</CODE> for a non-valid index (that is, an index to an =
"empty"=20
stack position). The types returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_type"><CODE>lua_typ=
e</CODE></A>=20
are coded by the following constants defined in <CODE>lua.h</CODE>:=20
<CODE>LUA_TNIL</CODE>, <CODE>LUA_TNUMBER</CODE>, =
<CODE>LUA_TBOOLEAN</CODE>,=20
<CODE>LUA_TSTRING</CODE>, <CODE>LUA_TTABLE</CODE>, =
<CODE>LUA_TFUNCTION</CODE>,=20
<CODE>LUA_TUSERDATA</CODE>, <CODE>LUA_TTHREAD</CODE>, and=20
<CODE>LUA_TLIGHTUSERDATA</CODE>.=20
<HR>

<H3><A name=3Dlua_typename><CODE>lua_typename</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>const char =
*lua_typename  (lua_State *L, int tp);</PRE>
<P>Returns the name of the type encoded by the value <CODE>tp</CODE>, =
which must=20
be one the values returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_type"><CODE>lua_typ=
e</CODE></A>.=20

<HR>

<H3><A name=3Dlua_Writer><CODE>lua_Writer</CODE></A></H3><PRE>typedef =
int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</PRE>
<P>The type of the writer function used by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_dump"><CODE>lua_dum=
p</CODE></A>.=20
Every time it produces another piece of chunk, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_dump"><CODE>lua_dum=
p</CODE></A>=20
calls the writer, passing along the buffer to be written =
(<CODE>p</CODE>), its=20
size (<CODE>sz</CODE>), and the <CODE>data</CODE> parameter supplied to =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_dump"><CODE>lua_dum=
p</CODE></A>.=20

<P>The writer returns an error code: 0&nbsp;means no errors; any other =
value=20
means an error and stops <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_dump"><CODE>lua_dum=
p</CODE></A>=20
from calling the writer again.=20
<HR>

<H3><A name=3Dlua_xmove><CODE>lua_xmove</CODE></A></H3>
<P><SPAN class=3Dapii>[-?, +?, <EM>-</EM>]</SPAN> <PRE>void lua_xmove =
(lua_State *from, lua_State *to, int n);</PRE>
<P>Exchange values between different threads of the <EM>same</EM> global =
state.=20
<P>This function pops <CODE>n</CODE> values from the stack =
<CODE>from</CODE>,=20
and pushes them onto the stack <CODE>to</CODE>.=20
<HR>

<H3><A name=3Dlua_yield><CODE>lua_yield</CODE></A></H3>
<P><SPAN class=3Dapii>[-?, +?, <EM>-</EM>]</SPAN> <PRE>int lua_yield  =
(lua_State *L, int nresults);</PRE>
<P>Yields a coroutine.=20
<P>This function should only be called as the return expression of a=20
C&nbsp;function, as follows: <PRE>     return lua_yield (L, nresults);
</PRE>
<P>When a C&nbsp;function calls <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_yield"><CODE>lua_yi=
eld</CODE></A>=20
in that way, the running coroutine suspends its execution, and the call =
to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_resume"><CODE>lua_r=
esume</CODE></A>=20
that started this coroutine returns. The parameter <CODE>nresults</CODE> =
is the=20
number of values from the stack that are passed as results to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_resume"><CODE>lua_r=
esume</CODE></A>.=20

<H2>3.8 - <A name=3D3.8>The Debug Interface</A></H2>
<P>Lua has no built-in debugging facilities. Instead, it offers a =
special=20
interface by means of functions and <EM>hooks</EM>. This interface =
allows the=20
construction of different kinds of debuggers, profilers, and other tools =
that=20
need "inside information" from the interpreter.=20
<HR>

<H3><A name=3Dlua_Debug><CODE>lua_Debug</CODE></A></H3><PRE>typedef =
struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int nups;                   /* (u) number of upvalues */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <EM>other fields</EM>
} lua_Debug;</PRE>
<P>A structure used to carry different pieces of information about an =
active=20
function. <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getstack"><CODE>lua=
_getstack</CODE></A>=20
fills only the private part of this structure, for later use. To fill =
the other=20
fields of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Debug"><CODE>lua_De=
bug</CODE></A>=20
with useful information, call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getinfo"><CODE>lua_=
getinfo</CODE></A>.=20

<P>The fields of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Debug"><CODE>lua_De=
bug</CODE></A>=20
have the following meaning:=20
<UL>
  <LI><B><CODE>source</CODE>:</B> If the function was defined in a =
string, then=20
  <CODE>source</CODE> is that string. If the function was defined in a =
file,=20
  then <CODE>source</CODE> starts with a '<CODE>@</CODE>' followed by =
the file=20
  name.=20
  <LI><B><CODE>short_src</CODE>:</B> a "printable" version of=20
  <CODE>source</CODE>, to be used in error messages.=20
  <LI><B><CODE>linedefined</CODE>:</B> the line number where the =
definition of=20
  the function starts.=20
  <LI><B><CODE>lastlinedefined</CODE>:</B> the line number where the =
definition=20
  of the function ends.=20
  <LI><B><CODE>what</CODE>:</B> the string <CODE>"Lua"</CODE> if the =
function is=20
  a Lua function, <CODE>"C"</CODE> if it is a C&nbsp;function,=20
  <CODE>"main"</CODE> if it is the main part of a chunk, and =
<CODE>"tail"</CODE>=20
  if it was a function that did a tail call. In the latter case, Lua has =
no=20
  other information about the function.=20
  <LI><B><CODE>currentline</CODE>:</B> the current line where the given =
function=20
  is executing. When no line information is available, =
<CODE>currentline</CODE>=20
  is set to -1.=20
  <LI><B><CODE>name</CODE>:</B> a reasonable name for the given =
function.=20
  Because functions in Lua are first-class values, they do not have a =
fixed=20
  name: some functions can be the value of multiple global variables, =
while=20
  others can be stored only in a table field. The =
<CODE>lua_getinfo</CODE>=20
  function checks how the function was called to find a suitable name. =
If it=20
  cannot find a name, then <CODE>name</CODE> is set to =
<CODE>NULL</CODE>.=20
  <LI><B><CODE>namewhat</CODE>:</B> explains the <CODE>name</CODE> =
field. The=20
  value of <CODE>namewhat</CODE> can be <CODE>"global"</CODE>,=20
  <CODE>"local"</CODE>, <CODE>"method"</CODE>, <CODE>"field"</CODE>,=20
  <CODE>"upvalue"</CODE>, or <CODE>""</CODE> (the empty string), =
according to=20
  how the function was called. (Lua uses the empty string when no other =
option=20
  seems to apply.)=20
  <LI><B><CODE>nups</CODE>:</B> the number of upvalues of the function. =
</LI></UL>
<HR>

<H3><A name=3Dlua_gethook><CODE>lua_gethook</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_Hook =
lua_gethook (lua_State *L);</PRE>
<P>Returns the current hook function.=20
<HR>

<H3><A name=3Dlua_gethookcount><CODE>lua_gethookcount</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_gethookcount (lua_State *L);</PRE>
<P>Returns the current hook count.=20
<HR>

<H3><A name=3Dlua_gethookmask><CODE>lua_gethookmask</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int =
lua_gethookmask (lua_State *L);</PRE>
<P>Returns the current hook mask.=20
<HR>

<H3><A name=3Dlua_getinfo><CODE>lua_getinfo</CODE></A></H3>
<P><SPAN class=3Dapii>[-(0|1), +(0|1|2), <EM>m</EM>]</SPAN> <PRE>int =
lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</PRE>
<P>Returns information about a specific function or function invocation. =

<P>To get information about a function invocation, the parameter =
<CODE>ar</CODE>=20
must be a valid activation record that was filled by a previous call to =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getstack"><CODE>lua=
_getstack</CODE></A>=20
or given as argument to a hook (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Hook"><CODE>lua_Hoo=
k</CODE></A>).=20

<P>To get information about a function you push it onto the stack and =
start the=20
<CODE>what</CODE> string with the character '<CODE>&gt;</CODE>'. (In =
that case,=20
<CODE>lua_getinfo</CODE> pops the function in the top of the stack.) For =

instance, to know in which line a function <CODE>f</CODE> was defined, =
you can=20
write the following code: <PRE>     lua_Debug ar;
     lua_getfield(L, LUA_GLOBALSINDEX, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</PRE>
<P>Each character in the string <CODE>what</CODE> selects some fields of =
the=20
structure <CODE>ar</CODE> to be filled or a value to be pushed on the =
stack:=20
<UL>
  <LI><B>'<CODE>n</CODE>':</B> fills in the field <CODE>name</CODE> and=20
  <CODE>namewhat</CODE>;=20
  <LI><B>'<CODE>S</CODE>':</B> fills in the fields <CODE>source</CODE>,=20
  <CODE>short_src</CODE>, <CODE>linedefined</CODE>,=20
  <CODE>lastlinedefined</CODE>, and <CODE>what</CODE>;=20
  <LI><B>'<CODE>l</CODE>':</B> fills in the field =
<CODE>currentline</CODE>;=20
  <LI><B>'<CODE>u</CODE>':</B> fills in the field <CODE>nups</CODE>;=20
  <LI><B>'<CODE>f</CODE>':</B> pushes onto the stack the function that =
is=20
  running at the given level;=20
  <LI><B>'<CODE>L</CODE>':</B> pushes onto the stack a table whose =
indices are=20
  the numbers of the lines that are valid on the function. (A <EM>valid=20
  line</EM> is a line with some associated code, that is, a line where =
you can=20
  put a break point. Non-valid lines include empty lines and comments.) =
</LI></UL>
<P>This function returns 0 on error (for instance, an invalid option in=20
<CODE>what</CODE>).=20
<HR>

<H3><A name=3Dlua_getlocal><CODE>lua_getlocal</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +(0|1), <EM>-</EM>]</SPAN> <PRE>const char =
*lua_getlocal (lua_State *L, lua_Debug *ar, int n);</PRE>
<P>Gets information about a local variable of a given activation record. =
The=20
parameter <CODE>ar</CODE> must be a valid activation record that was =
filled by a=20
previous call to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getstack"><CODE>lua=
_getstack</CODE></A>=20
or given as argument to a hook (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Hook"><CODE>lua_Hoo=
k</CODE></A>).=20
The index <CODE>n</CODE> selects which local variable to inspect (1 is =
the first=20
parameter or active local variable, and so on, until the last active =
local=20
variable). <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getlocal"><CODE>lua=
_getlocal</CODE></A>=20
pushes the variable's value onto the stack and returns its name.=20
<P>Variable names starting with '<CODE>(</CODE>' (open parentheses) =
represent=20
internal variables (loop control variables, temporaries, and =
C&nbsp;function=20
locals).=20
<P>Returns <CODE>NULL</CODE> (and pushes nothing) when the index is =
greater than=20
the number of active local variables.=20
<HR>

<H3><A name=3Dlua_getstack><CODE>lua_getstack</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_getstack =
(lua_State *L, int level, lua_Debug *ar);</PRE>
<P>Get information about the interpreter runtime stack.=20
<P>This function fills parts of a <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Debug"><CODE>lua_De=
bug</CODE></A>=20
structure with an identification of the <EM>activation record</EM> of =
the=20
function executing at a given level. Level&nbsp;0 is the current running =

function, whereas level <EM>n+1</EM> is the function that has called =
level=20
<EM>n</EM>. When there are no errors, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getstack"><CODE>lua=
_getstack</CODE></A>=20
returns 1; when called with a level greater than the stack depth, it =
returns 0.=20
<HR>

<H3><A name=3Dlua_getupvalue><CODE>lua_getupvalue</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +(0|1), <EM>-</EM>]</SPAN> <PRE>const char =
*lua_getupvalue (lua_State *L, int funcindex, int n);</PRE>
<P>Gets information about a closure's upvalue. (For Lua functions, =
upvalues are=20
the external local variables that the function uses, and that are =
consequently=20
included in its closure.) <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getupvalue"><CODE>l=
ua_getupvalue</CODE></A>=20
gets the index <CODE>n</CODE> of an upvalue, pushes the upvalue's value =
onto the=20
stack, and returns its name. <CODE>funcindex</CODE> points to the =
closure in the=20
stack. (Upvalues have no particular order, as they are active through =
the whole=20
function. So, they are numbered in an arbitrary order.)=20
<P>Returns <CODE>NULL</CODE> (and pushes nothing) when the index is =
greater than=20
the number of upvalues. For C&nbsp;functions, this function uses the =
empty=20
string <CODE>""</CODE> as a name for all upvalues.=20
<HR>

<H3><A name=3Dlua_Hook><CODE>lua_Hook</CODE></A></H3><PRE>typedef void =
(*lua_Hook) (lua_State *L, lua_Debug *ar);</PRE>
<P>Type for debugging hook functions.=20
<P>Whenever a hook is called, its <CODE>ar</CODE> argument has its field =

<CODE>event</CODE> set to the specific event that triggered the hook. =
Lua=20
identifies these events with the following constants: <A=20
name=3Dpdf-LUA_HOOKCALL><CODE>LUA_HOOKCALL</CODE></A>, <A=20
name=3Dpdf-LUA_HOOKRET><CODE>LUA_HOOKRET</CODE></A>, <A=20
name=3Dpdf-LUA_HOOKTAILRET><CODE>LUA_HOOKTAILRET</CODE></A>, <A=20
name=3Dpdf-LUA_HOOKLINE><CODE>LUA_HOOKLINE</CODE></A>, and <A=20
name=3Dpdf-LUA_HOOKCOUNT><CODE>LUA_HOOKCOUNT</CODE></A>. Moreover, for =
line=20
events, the field <CODE>currentline</CODE> is also set. To get the value =
of any=20
other field in <CODE>ar</CODE>, the hook must call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getinfo"><CODE>lua_=
getinfo</CODE></A>.=20
For return events, <CODE>event</CODE> can be <CODE>LUA_HOOKRET</CODE>, =
the=20
normal value, or <CODE>LUA_HOOKTAILRET</CODE>. In the latter case, Lua =
is=20
simulating a return from a function that did a tail call; in this case, =
it is=20
useless to call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getinfo"><CODE>lua_=
getinfo</CODE></A>.=20

<P>While Lua is running a hook, it disables other calls to hooks. =
Therefore, if=20
a hook calls back Lua to execute a function or a chunk, this execution =
occurs=20
without any calls to hooks.=20
<HR>

<H3><A name=3Dlua_sethook><CODE>lua_sethook</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>int lua_sethook =
(lua_State *L, lua_Hook f, int mask, int count);</PRE>
<P>Sets the debugging hook function.=20
<P>Argument <CODE>f</CODE> is the hook function. <CODE>mask</CODE> =
specifies on=20
which events the hook will be called: it is formed by a bitwise or of =
the=20
constants <A name=3Dpdf-LUA_MASKCALL><CODE>LUA_MASKCALL</CODE></A>, <A=20
name=3Dpdf-LUA_MASKRET><CODE>LUA_MASKRET</CODE></A>, <A=20
name=3Dpdf-LUA_MASKLINE><CODE>LUA_MASKLINE</CODE></A>, and <A=20
name=3Dpdf-LUA_MASKCOUNT><CODE>LUA_MASKCOUNT</CODE></A>. The =
<CODE>count</CODE>=20
argument is only meaningful when the mask includes =
<CODE>LUA_MASKCOUNT</CODE>.=20
For each event, the hook is called as explained below:=20
<UL>
  <LI><B>The call hook:</B> is called when the interpreter calls a =
function. The=20
  hook is called just after Lua enters the new function, before the =
function=20
  gets its arguments.=20
  <LI><B>The return hook:</B> is called when the interpreter returns =
from a=20
  function. The hook is called just before Lua leaves the function. You =
have no=20
  access to the values to be returned by the function.=20
  <LI><B>The line hook:</B> is called when the interpreter is about to =
start the=20
  execution of a new line of code, or when it jumps back in the code =
(even to=20
  the same line). (This event only happens while Lua is executing a Lua=20
  function.)=20
  <LI><B>The count hook:</B> is called after the interpreter executes =
every=20
  <CODE>count</CODE> instructions. (This event only happens while Lua is =

  executing a Lua function.) </LI></UL>
<P>A hook is disabled by setting <CODE>mask</CODE> to zero.=20
<HR>

<H3><A name=3Dlua_setlocal><CODE>lua_setlocal</CODE></A></H3>
<P><SPAN class=3Dapii>[-(0|1), +0, <EM>-</EM>]</SPAN> <PRE>const char =
*lua_setlocal (lua_State *L, lua_Debug *ar, int n);</PRE>
<P>Sets the value of a local variable of a given activation record. =
Parameters=20
<CODE>ar</CODE> and <CODE>n</CODE> are as in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getlocal"><CODE>lua=
_getlocal</CODE></A>=20
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getlocal"><CODE>lua=
_getlocal</CODE></A>).=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_setlocal"><CODE>lua=
_setlocal</CODE></A>=20
assigns the value at the top of the stack to the variable and returns =
its name.=20
It also pops the value from the stack.=20
<P>Returns <CODE>NULL</CODE> (and pops nothing) when the index is =
greater than=20
the number of active local variables.=20
<HR>

<H3><A name=3Dlua_setupvalue><CODE>lua_setupvalue</CODE></A></H3>
<P><SPAN class=3Dapii>[-(0|1), +0, <EM>-</EM>]</SPAN> <PRE>const char =
*lua_setupvalue (lua_State *L, int funcindex, int n);</PRE>
<P>Sets the value of a closure's upvalue. It assigns the value at the =
top of the=20
stack to the upvalue and returns its name. It also pops the value from =
the=20
stack. Parameters <CODE>funcindex</CODE> and <CODE>n</CODE> are as in =
the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getupvalue"><CODE>l=
ua_getupvalue</CODE></A>=20
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getupvalue"><CODE>l=
ua_getupvalue</CODE></A>).=20

<P>Returns <CODE>NULL</CODE> (and pops nothing) when the index is =
greater than=20
the number of upvalues.=20
<H1>4 - <A name=3D4>The Auxiliary Library</A></H1>
<P>The <EM>auxiliary library</EM> provides several convenient functions =
to=20
interface C with Lua. While the basic API provides the primitive =
functions for=20
all interactions between C and Lua, the auxiliary library provides =
higher-level=20
functions for some common tasks.=20
<P>All functions from the auxiliary library are defined in header file=20
<CODE>lauxlib.h</CODE> and have a prefix <CODE>luaL_</CODE>.=20
<P>All functions in the auxiliary library are built on top of the basic =
API, and=20
so they provide nothing that cannot be done with this API.=20
<P>Several functions in the auxiliary library are used to check =
C&nbsp;function=20
arguments. Their names are always <CODE>luaL_check*</CODE> or=20
<CODE>luaL_opt*</CODE>. All of these functions throw an error if the =
check is=20
not satisfied. Because the error message is formatted for arguments =
(e.g.,=20
"<CODE>bad argument #1</CODE>"), you should not use these functions for =
other=20
stack values.=20
<H2>4.1 - <A name=3D4.1>Functions and Types</A></H2>
<P>Here we list all functions and types from the auxiliary library in=20
alphabetical order.=20
<HR>

<H3><A name=3DluaL_addchar><CODE>luaL_addchar</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>void luaL_addchar =
(luaL_Buffer *B, char c);</PRE>
<P>Adds the character <CODE>c</CODE> to the buffer <CODE>B</CODE> (see =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>).=20

<HR>

<H3><A name=3DluaL_addlstring><CODE>luaL_addlstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>void =
luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</PRE>
<P>Adds the string pointed to by <CODE>s</CODE> with length =
<CODE>l</CODE> to=20
the buffer <CODE>B</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>).=20
The string may contain embedded zeros.=20
<HR>

<H3><A name=3DluaL_addsize><CODE>luaL_addsize</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>void luaL_addsize =
(luaL_Buffer *B, size_t n);</PRE>
<P>Adds to the buffer <CODE>B</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>)=20
a string of length <CODE>n</CODE> previously copied to the buffer area =
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_prepbuffer"><CODE>=
luaL_prepbuffer</CODE></A>).=20

<HR>

<H3><A name=3DluaL_addstring><CODE>luaL_addstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>void =
luaL_addstring (luaL_Buffer *B, const char *s);</PRE>
<P>Adds the zero-terminated string pointed to by <CODE>s</CODE> to the =
buffer=20
<CODE>B</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>).=20
The string may not contain embedded zeros.=20
<HR>

<H3><A name=3DluaL_addvalue><CODE>luaL_addvalue</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>m</EM>]</SPAN> <PRE>void =
luaL_addvalue (luaL_Buffer *B);</PRE>
<P>Adds the value at the top of the stack to the buffer <CODE>B</CODE> =
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>).=20
Pops the value.=20
<P>This is the only function on string buffers that can (and must) be =
called=20
with an extra element on the stack, which is the value to be added to =
the=20
buffer.=20
<HR>

<H3><A name=3DluaL_argcheck><CODE>luaL_argcheck</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>void =
luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);</PRE>
<P>Checks whether <CODE>cond</CODE> is true. If not, raises an error =
with the=20
following message, where <CODE>func</CODE> is retrieved from the call =
stack: <PRE>     bad argument #&lt;narg&gt; to &lt;func&gt; =
(&lt;extramsg&gt;)
</PRE>
<HR>

<H3><A name=3DluaL_argerror><CODE>luaL_argerror</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>int luaL_argerror =
(lua_State *L, int narg, const char *extramsg);</PRE>
<P>Raises an error with the following message, where <CODE>func</CODE> =
is=20
retrieved from the call stack: <PRE>     bad argument #&lt;narg&gt; to =
&lt;func&gt; (&lt;extramsg&gt;)
</PRE>
<P>This function never returns, but it is an idiom to use it in =
C&nbsp;functions=20
as <CODE>return luaL_argerror(<EM>args</EM>)</CODE>.=20
<HR>

<H3><A name=3DluaL_Buffer><CODE>luaL_Buffer</CODE></A></H3><PRE>typedef =
struct luaL_Buffer luaL_Buffer;</PRE>
<P>Type for a <EM>string buffer</EM>.=20
<P>A string buffer allows C&nbsp;code to build Lua strings piecemeal. =
Its=20
pattern of use is as follows:=20
<UL>
  <LI>First you declare a variable <CODE>b</CODE> of type <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>.=20

  <LI>Then you initialize it with a call <CODE>luaL_buffinit(L, =
&amp;b)</CODE>.=20
  <LI>Then you add string pieces to the buffer calling any of the=20
  <CODE>luaL_add*</CODE> functions.=20
  <LI>You finish by calling <CODE>luaL_pushresult(&amp;b)</CODE>. This =
call=20
  leaves the final string on the top of the stack. </LI></UL>
<P>During its normal operation, a string buffer uses a variable number =
of stack=20
slots. So, while using a buffer, you cannot assume that you know where =
the top=20
of the stack is. You can use the stack between successive calls to =
buffer=20
operations as long as that use is balanced; that is, when you call a =
buffer=20
operation, the stack is at the same level it was immediately after the =
previous=20
buffer operation. (The only exception to this rule is <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_addvalue"><CODE>lu=
aL_addvalue</CODE></A>.)=20
After calling <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_pushresult"><CODE>=
luaL_pushresult</CODE></A>=20
the stack is back to its level when the buffer was initialized, plus the =
final=20
string on its top.=20
<HR>

<H3><A name=3DluaL_buffinit><CODE>luaL_buffinit</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>e</EM>]</SPAN> <PRE>void =
luaL_buffinit (lua_State *L, luaL_Buffer *B);</PRE>
<P>Initializes a buffer <CODE>B</CODE>. This function does not allocate =
any=20
space; the buffer must be declared as a variable (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>).=20

<HR>

<H3><A name=3DluaL_callmeta><CODE>luaL_callmeta</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +(0|1), <EM>e</EM>]</SPAN> <PRE>int =
luaL_callmeta (lua_State *L, int obj, const char *e);</PRE>
<P>Calls a metamethod.=20
<P>If the object at index <CODE>obj</CODE> has a metatable and this =
metatable=20
has a field <CODE>e</CODE>, this function calls this field and passes =
the object=20
as its only argument. In this case this function returns 1 and pushes =
onto the=20
stack the value returned by the call. If there is no metatable or no =
metamethod,=20
this function returns 0 (without pushing any value on the stack).=20
<HR>

<H3><A name=3DluaL_checkany><CODE>luaL_checkany</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>void =
luaL_checkany (lua_State *L, int narg);</PRE>
<P>Checks whether the function has an argument of any type (including=20
<B>nil</B>) at position <CODE>narg</CODE>.=20
<HR>

<H3><A name=3DluaL_checkint><CODE>luaL_checkint</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>int luaL_checkint =
(lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number =
and=20
returns this number cast to an <CODE>int</CODE>.=20
<HR>

<H3><A name=3DluaL_checkinteger><CODE>luaL_checkinteger</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>lua_Integer =
luaL_checkinteger (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number =
and=20
returns this number cast to a <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Integer"><CODE>lua_=
Integer</CODE></A>.=20

<HR>

<H3><A name=3DluaL_checklong><CODE>luaL_checklong</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>long =
luaL_checklong (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number =
and=20
returns this number cast to a <CODE>long</CODE>.=20
<HR>

<H3><A name=3DluaL_checklstring><CODE>luaL_checklstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>const char =
*luaL_checklstring (lua_State *L, int narg, size_t *l);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a string =
and=20
returns this string; if <CODE>l</CODE> is not <CODE>NULL</CODE> fills=20
<CODE>*l</CODE> with the string's length.=20
<P>This function uses <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
to get its result, so all conversions and caveats of that function apply =
here.=20
<HR>

<H3><A name=3DluaL_checknumber><CODE>luaL_checknumber</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>lua_Number =
luaL_checknumber (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a number =
and=20
returns this number.=20
<HR>

<H3><A name=3DluaL_checkoption><CODE>luaL_checkoption</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>int =
luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a string =
and=20
searches for this string in the array <CODE>lst</CODE> (which must be=20
NULL-terminated). Returns the index in the array where the string was =
found.=20
Raises an error if the argument is not a string or if the string cannot =
be=20
found.=20
<P>If <CODE>def</CODE> is not <CODE>NULL</CODE>, the function uses=20
<CODE>def</CODE> as a default value when there is no argument =
<CODE>narg</CODE>=20
or if this argument is <B>nil</B>.=20
<P>This is a useful function for mapping strings to C&nbsp;enums. (The =
usual=20
convention in Lua libraries is to use strings instead of numbers to =
select=20
options.)=20
<HR>

<H3><A name=3DluaL_checkstack><CODE>luaL_checkstack</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>void =
luaL_checkstack (lua_State *L, int sz, const char *msg);</PRE>
<P>Grows the stack size to <CODE>top + sz</CODE> elements, raising an =
error if=20
the stack cannot grow to that size. <CODE>msg</CODE> is an additional =
text to go=20
into the error message.=20
<HR>

<H3><A name=3DluaL_checkstring><CODE>luaL_checkstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>const char =
*luaL_checkstring (lua_State *L, int narg);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a string =
and=20
returns this string.=20
<P>This function uses <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_tolstring"><CODE>lu=
a_tolstring</CODE></A>=20
to get its result, so all conversions and caveats of that function apply =
here.=20
<HR>

<H3><A name=3DluaL_checktype><CODE>luaL_checktype</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>void =
luaL_checktype (lua_State *L, int narg, int t);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> has type=20
<CODE>t</CODE>. See <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_type"><CODE>lua_typ=
e</CODE></A>=20
for the encoding of types for <CODE>t</CODE>.=20
<HR>

<H3><A name=3DluaL_checkudata><CODE>luaL_checkudata</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>void =
*luaL_checkudata (lua_State *L, int narg, const char *tname);</PRE>
<P>Checks whether the function argument <CODE>narg</CODE> is a userdata =
of the=20
type <CODE>tname</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_newmetatable"><COD=
E>luaL_newmetatable</CODE></A>).=20

<HR>

<H3><A name=3DluaL_dofile><CODE>luaL_dofile</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +?, <EM>m</EM>]</SPAN> <PRE>int luaL_dofile =
(lua_State *L, const char *filename);</PRE>
<P>Loads and runs the given file. It is defined as the following macro: =
<PRE>     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, =
0))
</PRE>
<P>It returns 0 if there are no errors or 1 in case of errors.=20
<HR>

<H3><A name=3DluaL_dostring><CODE>luaL_dostring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +?, <EM>m</EM>]</SPAN> <PRE>int luaL_dostring =
(lua_State *L, const char *str);</PRE>
<P>Loads and runs the given string. It is defined as the following =
macro: <PRE>     (luaL_loadstring(L, str) || lua_pcall(L, 0, =
LUA_MULTRET, 0))
</PRE>
<P>It returns 0 if there are no errors or 1 in case of errors.=20
<HR>

<H3><A name=3DluaL_error><CODE>luaL_error</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>int luaL_error =
(lua_State *L, const char *fmt, ...);</PRE>
<P>Raises an error. The error message format is given by =
<CODE>fmt</CODE> plus=20
any extra arguments, following the same rules of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_pushfstring"><CODE>=
lua_pushfstring</CODE></A>.=20
It also adds at the beginning of the message the file name and the line =
number=20
where the error occurred, if this information is available.=20
<P>This function never returns, but it is an idiom to use it in =
C&nbsp;functions=20
as <CODE>return luaL_error(<EM>args</EM>)</CODE>.=20
<HR>

<H3><A name=3DluaL_getmetafield><CODE>luaL_getmetafield</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +(0|1), <EM>m</EM>]</SPAN> <PRE>int =
luaL_getmetafield (lua_State *L, int obj, const char *e);</PRE>
<P>Pushes onto the stack the field <CODE>e</CODE> from the metatable of =
the=20
object at index <CODE>obj</CODE>. If the object does not have a =
metatable, or if=20
the metatable does not have this field, returns 0 and pushes nothing.=20
<HR>

<H3><A name=3DluaL_getmetatable><CODE>luaL_getmetatable</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>-</EM>]</SPAN> <PRE>void =
luaL_getmetatable (lua_State *L, const char *tname);</PRE>
<P>Pushes onto the stack the metatable associated with name =
<CODE>tname</CODE>=20
in the registry (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_newmetatable"><COD=
E>luaL_newmetatable</CODE></A>).=20

<HR>

<H3><A name=3DluaL_gsub><CODE>luaL_gsub</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>const char =
*luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</PRE>
<P>Creates a copy of string <CODE>s</CODE> by replacing any occurrence =
of the=20
string <CODE>p</CODE> with the string <CODE>r</CODE>. Pushes the =
resulting=20
string on the stack and returns it.=20
<HR>

<H3><A name=3DluaL_loadbuffer><CODE>luaL_loadbuffer</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>int =
luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</PRE>
<P>Loads a buffer as a Lua chunk. This function uses <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
to load the chunk in the buffer pointed to by <CODE>buff</CODE> with =
size=20
<CODE>sz</CODE>.=20
<P>This function returns the same results as <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>.=20
<CODE>name</CODE> is the chunk name, used for debug information and =
error=20
messages.=20
<HR>

<H3><A name=3DluaL_loadfile><CODE>luaL_loadfile</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>int luaL_loadfile =
(lua_State *L, const char *filename);</PRE>
<P>Loads a file as a Lua chunk. This function uses <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
to load the chunk in the file named <CODE>filename</CODE>. If=20
<CODE>filename</CODE> is <CODE>NULL</CODE>, then it loads from the =
standard=20
input. The first line in the file is ignored if it starts with a =
<CODE>#</CODE>.=20

<P>This function returns the same results as <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>,=20
but it has an extra error code <A=20
name=3Dpdf-LUA_ERRFILE><CODE>LUA_ERRFILE</CODE></A> if it cannot =
open/read the=20
file.=20
<P>As <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>,=20
this function only loads the chunk; it does not run it.=20
<HR>

<H3><A name=3DluaL_loadstring><CODE>luaL_loadstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>int =
luaL_loadstring (lua_State *L, const char *s);</PRE>
<P>Loads a string as a Lua chunk. This function uses <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>=20
to load the chunk in the zero-terminated string <CODE>s</CODE>.=20
<P>This function returns the same results as <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>.=20

<P>Also as <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_load"><CODE>lua_loa=
d</CODE></A>,=20
this function only loads the chunk; it does not run it.=20
<HR>

<H3><A name=3DluaL_newmetatable><CODE>luaL_newmetatable</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>int =
luaL_newmetatable (lua_State *L, const char *tname);</PRE>
<P>If the registry already has the key <CODE>tname</CODE>, returns 0. =
Otherwise,=20
creates a new table to be used as a metatable for userdata, adds it to =
the=20
registry with key <CODE>tname</CODE>, and returns 1.=20
<P>In both cases pushes onto the stack the final value associated with=20
<CODE>tname</CODE> in the registry.=20
<HR>

<H3><A name=3DluaL_newstate><CODE>luaL_newstate</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>lua_State =
*luaL_newstate (void);</PRE>
<P>Creates a new Lua state. It calls <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newstate"><CODE>lua=
_newstate</CODE></A>=20
with an allocator based on the standard&nbsp;C <CODE>realloc</CODE> =
function and=20
then sets a panic function (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_atpanic"><CODE>lua_=
atpanic</CODE></A>)=20
that prints an error message to the standard error output in case of =
fatal=20
errors.=20
<P>Returns the new state, or <CODE>NULL</CODE> if there is a memory =
allocation=20
error.=20
<HR>

<H3><A name=3DluaL_openlibs><CODE>luaL_openlibs</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>m</EM>]</SPAN> <PRE>void =
luaL_openlibs (lua_State *L);</PRE>
<P>Opens all standard Lua libraries into the given state.=20
<HR>

<H3><A name=3DluaL_optint><CODE>luaL_optint</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>int luaL_optint =
(lua_State *L, int narg, int d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this =
number=20
cast to an <CODE>int</CODE>. If this argument is absent or is =
<B>nil</B>,=20
returns <CODE>d</CODE>. Otherwise, raises an error.=20
<HR>

<H3><A name=3DluaL_optinteger><CODE>luaL_optinteger</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>lua_Integer =
luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this =
number=20
cast to a <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_Integer"><CODE>lua_=
Integer</CODE></A>.=20
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. =
Otherwise,=20
raises an error.=20
<HR>

<H3><A name=3DluaL_optlong><CODE>luaL_optlong</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>long luaL_optlong =
(lua_State *L, int narg, long d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this =
number=20
cast to a <CODE>long</CODE>. If this argument is absent or is =
<B>nil</B>,=20
returns <CODE>d</CODE>. Otherwise, raises an error.=20
<HR>

<H3><A name=3DluaL_optlstring><CODE>luaL_optlstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>const char =
*luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</PRE>
<P>If the function argument <CODE>narg</CODE> is a string, returns this =
string.=20
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. =
Otherwise,=20
raises an error.=20
<P>If <CODE>l</CODE> is not <CODE>NULL</CODE>, fills the position=20
<CODE>*l</CODE> with the results's length.=20
<HR>

<H3><A name=3DluaL_optnumber><CODE>luaL_optnumber</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>lua_Number =
luaL_optnumber (lua_State *L, int narg, lua_Number d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a number, returns this =
number.=20
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. =
Otherwise,=20
raises an error.=20
<HR>

<H3><A name=3DluaL_optstring><CODE>luaL_optstring</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>const char =
*luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);</PRE>
<P>If the function argument <CODE>narg</CODE> is a string, returns this =
string.=20
If this argument is absent or is <B>nil</B>, returns <CODE>d</CODE>. =
Otherwise,=20
raises an error.=20
<HR>

<H3><A name=3DluaL_prepbuffer><CODE>luaL_prepbuffer</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>char =
*luaL_prepbuffer (luaL_Buffer *B);</PRE>
<P>Returns an address to a space of size <A=20
name=3Dpdf-LUAL_BUFFERSIZE><CODE>LUAL_BUFFERSIZE</CODE></A> where you =
can copy a=20
string to be added to buffer <CODE>B</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Buffer"><CODE>luaL=
_Buffer</CODE></A>).=20
After copying the string into this space you must call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_addsize"><CODE>lua=
L_addsize</CODE></A>=20
with the size of the string to actually add it to the buffer.=20
<HR>

<H3><A name=3DluaL_pushresult><CODE>luaL_pushresult</CODE></A></H3>
<P><SPAN class=3Dapii>[-?, +1, <EM>m</EM>]</SPAN> <PRE>void =
luaL_pushresult (luaL_Buffer *B);</PRE>
<P>Finishes the use of buffer <CODE>B</CODE> leaving the final string on =
the top=20
of the stack.=20
<HR>

<H3><A name=3DluaL_ref><CODE>luaL_ref</CODE></A></H3>
<P><SPAN class=3Dapii>[-1, +0, <EM>m</EM>]</SPAN> <PRE>int luaL_ref =
(lua_State *L, int t);</PRE>
<P>Creates and returns a <EM>reference</EM>, in the table at index=20
<CODE>t</CODE>, for the object at the top of the stack (and pops the =
object).=20
<P>A reference is a unique integer key. As long as you do not manually =
add=20
integer keys into table <CODE>t</CODE>, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_ref"><CODE>luaL_re=
f</CODE></A>=20
ensures the uniqueness of the key it returns. You can retrieve an object =

referred by reference <CODE>r</CODE> by calling <CODE>lua_rawgeti(L, t,=20
r)</CODE>. Function <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_unref"><CODE>luaL_=
unref</CODE></A>=20
frees a reference and its associated object.=20
<P>If the object at the top of the stack is <B>nil</B>, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_ref"><CODE>luaL_re=
f</CODE></A>=20
returns the constant <A =
name=3Dpdf-LUA_REFNIL><CODE>LUA_REFNIL</CODE></A>. The=20
constant <A name=3Dpdf-LUA_NOREF><CODE>LUA_NOREF</CODE></A> is =
guaranteed to be=20
different from any reference returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_ref"><CODE>luaL_re=
f</CODE></A>.=20

<HR>

<H3><A name=3DluaL_Reg><CODE>luaL_Reg</CODE></A></H3><PRE>typedef struct =
luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</PRE>
<P>Type for arrays of functions to be registered by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_register"><CODE>lu=
aL_register</CODE></A>.=20
<CODE>name</CODE> is the function name and <CODE>func</CODE> is a =
pointer to the=20
function. Any array of <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Reg"><CODE>luaL_Re=
g</CODE></A>=20
must end with an sentinel entry in which both <CODE>name</CODE> and=20
<CODE>func</CODE> are <CODE>NULL</CODE>.=20
<HR>

<H3><A name=3DluaL_register><CODE>luaL_register</CODE></A></H3>
<P><SPAN class=3Dapii>[-(0|1), +1, <EM>m</EM>]</SPAN> <PRE>void =
luaL_register (lua_State *L,
                    const char *libname,
                    const luaL_Reg *l);</PRE>
<P>Opens a library.=20
<P>When called with <CODE>libname</CODE> equal to <CODE>NULL</CODE>, it =
simply=20
registers all functions in the list <CODE>l</CODE> (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_Reg"><CODE>luaL_Re=
g</CODE></A>)=20
into the table on the top of the stack.=20
<P>When called with a non-null <CODE>libname</CODE>, =
<CODE>luaL_register</CODE>=20
creates a new table <CODE>t</CODE>, sets it as the value of the global =
variable=20
<CODE>libname</CODE>, sets it as the value of=20
<CODE>package.loaded[libname]</CODE>, and registers on it all functions =
in the=20
list <CODE>l</CODE>. If there is a table in =
<CODE>package.loaded[libname]</CODE>=20
or in variable <CODE>libname</CODE>, reuses this table instead of =
creating a new=20
one.=20
<P>In any case the function leaves the table on the top of the stack.=20
<HR>

<H3><A name=3DluaL_typename><CODE>luaL_typename</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>const char =
*luaL_typename (lua_State *L, int index);</PRE>
<P>Returns the name of the type of the value at the given index.=20
<HR>

<H3><A name=3DluaL_typerror><CODE>luaL_typerror</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>v</EM>]</SPAN> <PRE>int luaL_typerror =
(lua_State *L, int narg, const char *tname);</PRE>
<P>Generates an error with a message like the following: <PRE>     =
<EM>location</EM>: bad argument <EM>narg</EM> to '<EM>func</EM>' =
(<EM>tname</EM> expected, got <EM>rt</EM>)
</PRE>
<P>where <CODE><EM>location</EM></CODE> is produced by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_where"><CODE>luaL_=
where</CODE></A>,=20
<CODE><EM>func</EM></CODE> is the name of the current function, and=20
<CODE><EM>rt</EM></CODE> is the type name of the actual argument.=20
<HR>

<H3><A name=3DluaL_unref><CODE>luaL_unref</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +0, <EM>-</EM>]</SPAN> <PRE>void luaL_unref =
(lua_State *L, int t, int ref);</PRE>
<P>Releases reference <CODE>ref</CODE> from the table at index =
<CODE>t</CODE>=20
(see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_ref"><CODE>luaL_re=
f</CODE></A>).=20
The entry is removed from the table, so that the referred object can be=20
collected. The reference <CODE>ref</CODE> is also freed to be used =
again.=20
<P>If <CODE>ref</CODE> is <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-LUA_NOREF"><CODE>LU=
A_NOREF</CODE></A>=20
or <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-LUA_REFNIL"><CODE>L=
UA_REFNIL</CODE></A>,=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_unref"><CODE>luaL_=
unref</CODE></A>=20
does nothing.=20
<HR>

<H3><A name=3DluaL_where><CODE>luaL_where</CODE></A></H3>
<P><SPAN class=3Dapii>[-0, +1, <EM>m</EM>]</SPAN> <PRE>void luaL_where =
(lua_State *L, int lvl);</PRE>
<P>Pushes onto the stack a string identifying the current position of =
the=20
control at level <CODE>lvl</CODE> in the call stack. Typically this =
string has=20
the following format: <PRE>     <EM>chunkname</EM>:<EM>currentline</EM>:
</PRE>
<P>Level&nbsp;0 is the running function, level&nbsp;1 is the function =
that=20
called the running function, etc.=20
<P>This function is used to build a prefix for error messages.=20
<H1>5 - <A name=3D5>Standard Libraries</A></H1>
<P>The standard Lua libraries provide useful functions that are =
implemented=20
directly through the C&nbsp;API. Some of these functions provide =
essential=20
services to the language (e.g., <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-type"><CODE>type</C=
ODE></A>=20
and <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-getmetatable"><CODE=
>getmetatable</CODE></A>);=20
others provide access to "outside" services (e.g., I/O); and others =
could be=20
implemented in Lua itself, but are quite useful or have critical =
performance=20
requirements that deserve an implementation in C (e.g., <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-table.sort"><CODE>t=
able.sort</CODE></A>).=20

<P>All libraries are implemented through the official C&nbsp;API and are =

provided as separate C&nbsp;modules. Currently, Lua has the following =
standard=20
libraries:=20
<UL>
  <LI>basic library, which includes the coroutine sub-library;=20
  <LI>package library;=20
  <LI>string manipulation;=20
  <LI>table manipulation;=20
  <LI>mathematical functions (sin, log, etc.);=20
  <LI>input and output;=20
  <LI>operating system facilities;=20
  <LI>debug facilities. </LI></UL>
<P>Except for the basic and package libraries, each library provides all =
its=20
functions as fields of a global table or as methods of its objects.=20
<P>To have access to these libraries, the C&nbsp;host program should =
call the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_openlibs"><CODE>lu=
aL_openlibs</CODE></A>=20
function, which opens all standard libraries. Alternatively, it can open =
them=20
individually by calling <A =
name=3Dpdf-luaopen_base><CODE>luaopen_base</CODE></A>=20
(for the basic library), <A=20
name=3Dpdf-luaopen_package><CODE>luaopen_package</CODE></A> (for the =
package=20
library), <A name=3Dpdf-luaopen_string><CODE>luaopen_string</CODE></A> =
(for the=20
string library), <A =
name=3Dpdf-luaopen_table><CODE>luaopen_table</CODE></A> (for=20
the table library), <A =
name=3Dpdf-luaopen_math><CODE>luaopen_math</CODE></A> (for=20
the mathematical library), <A =
name=3Dpdf-luaopen_io><CODE>luaopen_io</CODE></A>=20
(for the I/O library), <A =
name=3Dpdf-luaopen_os><CODE>luaopen_os</CODE></A> (for=20
the Operating System library), and <A=20
name=3Dpdf-luaopen_debug><CODE>luaopen_debug</CODE></A> (for the debug =
library).=20
These functions are declared in <A =
name=3Dpdf-lualib.h><CODE>lualib.h</CODE></A>=20
and should not be called directly: you must call them like any other Lua =

C&nbsp;function, e.g., by using <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_call"><CODE>lua_cal=
l</CODE></A>.=20

<H2>5.1 - <A name=3D5.1>Basic Functions</A></H2>
<P>The basic library provides some core functions to Lua. If you do not =
include=20
this library in your application, you should check carefully whether you =
need to=20
provide implementations for some of its facilities.=20
<P>
<HR>

<H3><A name=3Dpdf-assert><CODE>assert (v [, =
message])</CODE></A></H3>Issues an=20
error when the value of its argument <CODE>v</CODE> is false (i.e., =
<B>nil</B>=20
or <B>false</B>); otherwise, returns all its arguments. =
<CODE>message</CODE> is=20
an error message; when absent, it defaults to "assertion failed!"=20
<P>
<HR>

<H3><A name=3Dpdf-collectgarbage><CODE>collectgarbage (opt [,=20
arg])</CODE></A></H3>
<P>This function is a generic interface to the garbage collector. It =
performs=20
different functions according to its first argument, <CODE>opt</CODE>:=20
<UL>
  <LI><B>"stop":</B> stops the garbage collector.=20
  <LI><B>"restart":</B> restarts the garbage collector.=20
  <LI><B>"collect":</B> performs a full garbage-collection cycle.=20
  <LI><B>"count":</B> returns the total memory in use by Lua (in =
Kbytes).=20
  <LI><B>"step":</B> performs a garbage-collection step. The step "size" =
is=20
  controlled by <CODE>arg</CODE> (larger values mean more steps) in a=20
  non-specified way. If you want to control the step size you must=20
  experimentally tune the value of <CODE>arg</CODE>. Returns <B>true</B> =
if the=20
  step finished a collection cycle.=20
  <LI><B>"setpause":</B> sets <CODE>arg</CODE> as the new value for the=20
  <EM>pause</EM> of the collector (see <A=20
  href=3D"http://www.lua.org/manual/5.1/manual.html#2.10">=A72.10</A>). =
Returns the=20
  previous value for <EM>pause</EM>.=20
  <LI><B>"setstepmul":</B> sets <CODE>arg</CODE> as the new value for =
the=20
  <EM>step multiplier</EM> of the collector (see <A=20
  href=3D"http://www.lua.org/manual/5.1/manual.html#2.10">=A72.10</A>). =
Returns the=20
  previous value for <EM>step</EM>. </LI></UL>
<P>
<HR>

<H3><A name=3Dpdf-dofile><CODE>dofile (filename)</CODE></A></H3>Opens =
the named=20
file and executes its contents as a Lua chunk. When called without =
arguments,=20
<CODE>dofile</CODE> executes the contents of the standard input=20
(<CODE>stdin</CODE>). Returns all values returned by the chunk. In case =
of=20
errors, <CODE>dofile</CODE> propagates the error to its caller (that is, =

<CODE>dofile</CODE> does not run in protected mode).=20
<P>
<HR>

<H3><A name=3Dpdf-error><CODE>error (message [, =
level])</CODE></A></H3>Terminates=20
the last protected function called and returns <CODE>message</CODE> as =
the error=20
message. Function <CODE>error</CODE> never returns.=20
<P>Usually, <CODE>error</CODE> adds some information about the error =
position at=20
the beginning of the message. The <CODE>level</CODE> argument specifies =
how to=20
get the error position. With level&nbsp;1 (the default), the error =
position is=20
where the <CODE>error</CODE> function was called. Level&nbsp;2 points =
the error=20
to where the function that called <CODE>error</CODE> was called; and so =
on.=20
Passing a level&nbsp;0 avoids the addition of error position information =
to the=20
message.=20
<P>
<HR>

<H3><A name=3Dpdf-_G><CODE>_G</CODE></A></H3>A global variable (not a =
function)=20
that holds the global environment (that is, <CODE>_G._G =3D _G</CODE>). =
Lua itself=20
does not use this variable; changing its value does not affect any =
environment,=20
nor vice-versa. (Use <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-setfenv"><CODE>setf=
env</CODE></A>=20
to change environments.)=20
<P>
<HR>

<H3><A name=3Dpdf-getfenv><CODE>getfenv ([f])</CODE></A></H3>Returns the =
current=20
environment in use by the function. <CODE>f</CODE> can be a Lua function =
or a=20
number that specifies the function at that stack level: Level&nbsp;1 is =
the=20
function calling <CODE>getfenv</CODE>. If the given function is not a =
Lua=20
function, or if <CODE>f</CODE> is 0, <CODE>getfenv</CODE> returns the =
global=20
environment. The default for <CODE>f</CODE> is 1.=20
<P>
<HR>

<H3><A name=3Dpdf-getmetatable><CODE>getmetatable =
(object)</CODE></A></H3>
<P>If <CODE>object</CODE> does not have a metatable, returns <B>nil</B>. =

Otherwise, if the object's metatable has a <CODE>"__metatable"</CODE> =
field,=20
returns the associated value. Otherwise, returns the metatable of the =
given=20
object.=20
<P>
<HR>

<H3><A name=3Dpdf-ipairs><CODE>ipairs (t)</CODE></A></H3>
<P>Returns three values: an iterator function, the table <CODE>t</CODE>, =
and 0,=20
so that the construction <PRE>     for i,v in ipairs(t) do <EM>body</EM> =
end
</PRE>
<P>will iterate over the pairs (<CODE>1,t[1]</CODE>), =
(<CODE>2,t[2]</CODE>),=20
=B7=B7=B7, up to the first integer key absent from the table.=20
<P>
<HR>

<H3><A name=3Dpdf-load><CODE>load (func [, chunkname])</CODE></A></H3>
<P>Loads a chunk using function <CODE>func</CODE> to get its pieces. =
Each call=20
to <CODE>func</CODE> must return a string that concatenates with =
previous=20
results. A return of an empty string, <B>nil</B>, or no value signals =
the end of=20
the chunk.=20
<P>If there are no errors, returns the compiled chunk as a function; =
otherwise,=20
returns <B>nil</B> plus the error message. The environment of the =
returned=20
function is the global environment.=20
<P><CODE>chunkname</CODE> is used as the chunk name for error messages =
and debug=20
information. When absent, it defaults to "<CODE>=3D(load)</CODE>".=20
<P>
<HR>

<H3><A name=3Dpdf-loadfile><CODE>loadfile ([filename])</CODE></A></H3>
<P>Similar to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-load"><CODE>load</C=
ODE></A>,=20
but gets the chunk from file <CODE>filename</CODE> or from the standard =
input,=20
if no file name is given.=20
<P>
<HR>

<H3><A name=3Dpdf-loadstring><CODE>loadstring (string [,=20
chunkname])</CODE></A></H3>
<P>Similar to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-load"><CODE>load</C=
ODE></A>,=20
but gets the chunk from the given string.=20
<P>To load and run a given string, use the idiom <PRE>     =
assert(loadstring(s))()
</PRE>
<P>When absent, <CODE>chunkname</CODE> defaults to the given string.=20
<P>
<HR>

<H3><A name=3Dpdf-next><CODE>next (table [, index])</CODE></A></H3>
<P>Allows a program to traverse all fields of a table. Its first =
argument is a=20
table and its second argument is an index in this table. =
<CODE>next</CODE>=20
returns the next index of the table and its associated value. When =
called with=20
<B>nil</B> as its second argument, <CODE>next</CODE> returns an initial =
index=20
and its associated value. When called with the last index, or with =
<B>nil</B> in=20
an empty table, <CODE>next</CODE> returns <B>nil</B>. If the second =
argument is=20
absent, then it is interpreted as <B>nil</B>. In particular, you can use =

<CODE>next(t)</CODE> to check whether a table is empty.=20
<P>The order in which the indices are enumerated is not specified, =
<EM>even for=20
numeric indices</EM>. (To traverse a table in numeric order, use a =
numerical=20
<B>for</B> or the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-ipairs"><CODE>ipair=
s</CODE></A>=20
function.)=20
<P>The behavior of <CODE>next</CODE> is <EM>undefined</EM> if, during =
the=20
traversal, you assign any value to a non-existent field in the table. =
You may=20
however modify existing fields. In particular, you may clear existing =
fields.=20
<P>
<HR>

<H3><A name=3Dpdf-pairs><CODE>pairs (t)</CODE></A></H3>
<P>Returns three values: the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-next"><CODE>next</C=
ODE></A>=20
function, the table <CODE>t</CODE>, and <B>nil</B>, so that the =
construction <PRE>     for k,v in pairs(t) do <EM>body</EM> end
</PRE>
<P>will iterate over all key=96value pairs of table <CODE>t</CODE>.=20
<P>See function <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-next"><CODE>next</C=
ODE></A>=20
for the caveats of modifying the table during its traversal.=20
<P>
<HR>

<H3><A name=3Dpdf-pcall><CODE>pcall (f, arg1, =B7=B7=B7)</CODE></A></H3>
<P>Calls function <CODE>f</CODE> with the given arguments in =
<EM>protected=20
mode</EM>. This means that any error inside&nbsp;<CODE>f</CODE> is not=20
propagated; instead, <CODE>pcall</CODE> catches the error and returns a =
status=20
code. Its first result is the status code (a boolean), which is true if =
the call=20
succeeds without errors. In such case, <CODE>pcall</CODE> also returns =
all=20
results from the call, after this first result. In case of any error,=20
<CODE>pcall</CODE> returns <B>false</B> plus the error message.=20
<P>
<HR>

<H3><A name=3Dpdf-print><CODE>print (=B7=B7=B7)</CODE></A></H3>Receives =
any number of=20
arguments, and prints their values to <CODE>stdout</CODE>, using the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-tostring"><CODE>tos=
tring</CODE></A>=20
function to convert them to strings. <CODE>print</CODE> is not intended =
for=20
formatted output, but only as a quick way to show a value, typically for =

debugging. For formatted output, use <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-string.format"><COD=
E>string.format</CODE></A>.=20

<P>
<HR>

<H3><A name=3Dpdf-rawequal><CODE>rawequal (v1, v2)</CODE></A></H3>Checks =
whether=20
<CODE>v1</CODE> is equal to <CODE>v2</CODE>, without invoking any =
metamethod.=20
Returns a boolean.=20
<P>
<HR>

<H3><A name=3Dpdf-rawget><CODE>rawget (table, index)</CODE></A></H3>Gets =
the real=20
value of <CODE>table[index]</CODE>, without invoking any metamethod.=20
<CODE>table</CODE> must be a table; <CODE>index</CODE> may be any value. =

<P>
<HR>

<H3><A name=3Dpdf-rawset><CODE>rawset (table, index, =
value)</CODE></A></H3>Sets=20
the real value of <CODE>table[index]</CODE> to <CODE>value</CODE>, =
without=20
invoking any metamethod. <CODE>table</CODE> must be a table, =
<CODE>index</CODE>=20
any value different from <B>nil</B>, and <CODE>value</CODE> any Lua =
value.=20
<P>This function returns <CODE>table</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-select><CODE>select (index, =B7=B7=B7)</CODE></A></H3>
<P>If <CODE>index</CODE> is a number, returns all arguments after =
argument=20
number <CODE>index</CODE>. Otherwise, <CODE>index</CODE> must be the =
string=20
<CODE>"#"</CODE>, and <CODE>select</CODE> returns the total number of =
extra=20
arguments it received.=20
<P>
<HR>

<H3><A name=3Dpdf-setfenv><CODE>setfenv (f, table)</CODE></A></H3>
<P>Sets the environment to be used by the given function. <CODE>f</CODE> =
can be=20
a Lua function or a number that specifies the function at that stack =
level:=20
Level&nbsp;1 is the function calling <CODE>setfenv</CODE>. =
<CODE>setfenv</CODE>=20
returns the given function.=20
<P>As a special case, when <CODE>f</CODE> is 0 <CODE>setfenv</CODE> =
changes the=20
environment of the running thread. In this case, <CODE>setfenv</CODE> =
returns no=20
values.=20
<P>
<HR>

<H3><A name=3Dpdf-setmetatable><CODE>setmetatable (table,=20
metatable)</CODE></A></H3>
<P>Sets the metatable for the given table. (You cannot change the =
metatable of=20
other types from Lua, only from&nbsp;C.) If <CODE>metatable</CODE> is=20
<B>nil</B>, removes the metatable of the given table. If the original =
metatable=20
has a <CODE>"__metatable"</CODE> field, raises an error.=20
<P>This function returns <CODE>table</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-tonumber><CODE>tonumber (e [, =
base])</CODE></A></H3>Tries to=20
convert its argument to a number. If the argument is already a number or =
a=20
string convertible to a number, then <CODE>tonumber</CODE> returns this =
number;=20
otherwise, it returns <B>nil</B>.=20
<P>An optional argument specifies the base to interpret the numeral. The =
base=20
may be any integer between 2 and 36, inclusive. In bases above&nbsp;10, =
the=20
letter '<CODE>A</CODE>' (in either upper or lower case) =
represents&nbsp;10,=20
'<CODE>B</CODE>' represents&nbsp;11, and so forth, with '<CODE>Z</CODE>' =

representing 35. In base 10 (the default), the number can have a decimal =
part,=20
as well as an optional exponent part (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.1">=A72.1</A>). In =
other bases,=20
only unsigned integers are accepted.=20
<P>
<HR>

<H3><A name=3Dpdf-tostring><CODE>tostring (e)</CODE></A></H3>Receives an =
argument=20
of any type and converts it to a string in a reasonable format. For =
complete=20
control of how numbers are converted, use <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-string.format"><COD=
E>string.format</CODE></A>.=20

<P>If the metatable of <CODE>e</CODE> has a <CODE>"__tostring"</CODE> =
field,=20
then <CODE>tostring</CODE> calls the corresponding value with =
<CODE>e</CODE> as=20
argument, and uses the result of the call as its result.=20
<P>
<HR>

<H3><A name=3Dpdf-type><CODE>type (v)</CODE></A></H3>Returns the type of =
its only=20
argument, coded as a string. The possible results of this function are=20
"<CODE>nil</CODE>" (a string, not the value <B>nil</B>), =
"<CODE>number</CODE>",=20
"<CODE>string</CODE>", "<CODE>boolean</CODE>", "<CODE>table</CODE>",=20
"<CODE>function</CODE>", "<CODE>thread</CODE>", and =
"<CODE>userdata</CODE>".=20
<P>
<HR>

<H3><A name=3Dpdf-unpack><CODE>unpack (list [, i [, =
j]])</CODE></A></H3>Returns=20
the elements from the given table. This function is equivalent to <PRE>  =
   return list[i], list[i+1], =B7=B7=B7, list[j]
</PRE>
<P>except that the above code can be written only for a fixed number of=20
elements. By default, <CODE>i</CODE> is&nbsp;1 and <CODE>j</CODE> is the =
length=20
of the list, as defined by the length operator (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.5">=A72.5.5</A>).=20
<P>
<HR>

<H3><A name=3Dpdf-_VERSION><CODE>_VERSION</CODE></A></H3>A global =
variable (not a=20
function) that holds a string containing the current interpreter =
version. The=20
current contents of this variable is "<CODE>Lua 5.1</CODE>".=20
<P>
<HR>

<H3><A name=3Dpdf-xpcall><CODE>xpcall (f, err)</CODE></A></H3>
<P>This function is similar to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-pcall"><CODE>pcall<=
/CODE></A>,=20
except that you can set a new error handler.=20
<P><CODE>xpcall</CODE> calls function <CODE>f</CODE> in protected mode, =
using=20
<CODE>err</CODE> as the error handler. Any error inside <CODE>f</CODE> =
is not=20
propagated; instead, <CODE>xpcall</CODE> catches the error, calls the=20
<CODE>err</CODE> function with the original error object, and returns a =
status=20
code. Its first result is the status code (a boolean), which is true if =
the call=20
succeeds without errors. In this case, <CODE>xpcall</CODE> also returns =
all=20
results from the call, after this first result. In case of any error,=20
<CODE>xpcall</CODE> returns <B>false</B> plus the result from =
<CODE>err</CODE>.=20
<H2>5.2 - <A name=3D5.2>Coroutine Manipulation</A></H2>
<P>The operations related to coroutines comprise a sub-library of the =
basic=20
library and come inside the table <A=20
name=3Dpdf-coroutine><CODE>coroutine</CODE></A>. See <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.11">=A72.11</A> for =
a general=20
description of coroutines.=20
<P>
<HR>

<H3><A name=3Dpdf-coroutine.create><CODE>coroutine.create =
(f)</CODE></A></H3>
<P>Creates a new coroutine, with body <CODE>f</CODE>. <CODE>f</CODE> =
must be a=20
Lua function. Returns this new coroutine, an object with type=20
<CODE>"thread"</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-coroutine.resume><CODE>coroutine.resume (co [, val1,=20
=B7=B7=B7])</CODE></A></H3>
<P>Starts or continues the execution of coroutine <CODE>co</CODE>. The =
first=20
time you resume a coroutine, it starts running its body. The values=20
<CODE>val1</CODE>, =B7=B7=B7 are passed as the arguments to the body =
function. If the=20
coroutine has yielded, <CODE>resume</CODE> restarts it; the values=20
<CODE>val1</CODE>, =B7=B7=B7 are passed as the results from the yield.=20
<P>If the coroutine runs without any errors, <CODE>resume</CODE> returns =

<B>true</B> plus any values passed to <CODE>yield</CODE> (if the =
coroutine=20
yields) or any values returned by the body function (if the coroutine=20
terminates). If there is any error, <CODE>resume</CODE> returns =
<B>false</B>=20
plus the error message.=20
<P>
<HR>

<H3><A name=3Dpdf-coroutine.running><CODE>coroutine.running =
()</CODE></A></H3>
<P>Returns the running coroutine, or <B>nil</B> when called by the main =
thread.=20
<P>
<HR>

<H3><A name=3Dpdf-coroutine.status><CODE>coroutine.status =
(co)</CODE></A></H3>
<P>Returns the status of coroutine <CODE>co</CODE>, as a string:=20
<CODE>"running"</CODE>, if the coroutine is running (that is, it called=20
<CODE>status</CODE>); <CODE>"suspended"</CODE>, if the coroutine is =
suspended in=20
a call to <CODE>yield</CODE>, or if it has not started running yet;=20
<CODE>"normal"</CODE> if the coroutine is active but not running (that =
is, it=20
has resumed another coroutine); and <CODE>"dead"</CODE> if the coroutine =
has=20
finished its body function, or if it has stopped with an error.=20
<P>
<HR>

<H3><A name=3Dpdf-coroutine.wrap><CODE>coroutine.wrap =
(f)</CODE></A></H3>
<P>Creates a new coroutine, with body <CODE>f</CODE>. <CODE>f</CODE> =
must be a=20
Lua function. Returns a function that resumes the coroutine each time it =
is=20
called. Any arguments passed to the function behave as the extra =
arguments to=20
<CODE>resume</CODE>. Returns the same values returned by =
<CODE>resume</CODE>,=20
except the first boolean. In case of error, propagates the error.=20
<P>
<HR>

<H3><A name=3Dpdf-coroutine.yield><CODE>coroutine.yield =
(=B7=B7=B7)</CODE></A></H3>
<P>Suspends the execution of the calling coroutine. The coroutine cannot =
be=20
running a C&nbsp;function, a metamethod, or an iterator. Any arguments =
to=20
<CODE>yield</CODE> are passed as extra results to <CODE>resume</CODE>.=20
<H2>5.3 - <A name=3D5.3>Modules</A></H2>
<P>The package library provides basic facilities for loading and =
building=20
modules in Lua. It exports two of its functions directly in the global=20
environment: <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
and <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-module"><CODE>modul=
e</CODE></A>.=20
Everything else is exported in a table <A=20
name=3Dpdf-package><CODE>package</CODE></A>.=20
<P>
<HR>

<H3><A name=3Dpdf-module><CODE>module (name [, =
=B7=B7=B7])</CODE></A></H3>
<P>Creates a module. If there is a table in =
<CODE>package.loaded[name]</CODE>,=20
this table is the module. Otherwise, if there is a global table =
<CODE>t</CODE>=20
with the given name, this table is the module. Otherwise creates a new =
table=20
<CODE>t</CODE> and sets it as the value of the global <CODE>name</CODE> =
and the=20
value of <CODE>package.loaded[name]</CODE>. This function also =
initializes=20
<CODE>t._NAME</CODE> with the given name, <CODE>t._M</CODE> with the =
module=20
(<CODE>t</CODE> itself), and <CODE>t._PACKAGE</CODE> with the package =
name (the=20
full module name minus last component; see below). Finally, =
<CODE>module</CODE>=20
sets <CODE>t</CODE> as the new environment of the current function and =
the new=20
value of <CODE>package.loaded[name]</CODE>, so that <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
returns <CODE>t</CODE>.=20
<P>If <CODE>name</CODE> is a compound name (that is, one with components =

separated by dots), <CODE>module</CODE> creates (or reuses, if they =
already=20
exist) tables for each component. For instance, if <CODE>name</CODE> is=20
<CODE>a.b.c</CODE>, then <CODE>module</CODE> stores the module table in =
field=20
<CODE>c</CODE> of field <CODE>b</CODE> of global <CODE>a</CODE>.=20
<P>This function can receive optional <EM>options</EM> after the module =
name,=20
where each option is a function to be applied over the module.=20
<P>
<HR>

<H3><A name=3Dpdf-require><CODE>require (modname)</CODE></A></H3>
<P>Loads the given module. The function starts by looking into the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.loaded"><CO=
DE>package.loaded</CODE></A>=20
table to determine whether <CODE>modname</CODE> is already loaded. If it =
is,=20
then <CODE>require</CODE> returns the value stored at=20
<CODE>package.loaded[modname]</CODE>. Otherwise, it tries to find a=20
<EM>loader</EM> for the module.=20
<P>To find a loader, <CODE>require</CODE> is guided by the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders"><C=
ODE>package.loaders</CODE></A>=20
array. By changing this array, we can change how <CODE>require</CODE> =
looks for=20
a module. The following explanation is based on the default =
configuration for <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders"><C=
ODE>package.loaders</CODE></A>.=20

<P>First <CODE>require</CODE> queries =
<CODE>package.preload[modname]</CODE>. If=20
it has a value, this value (which should be a function) is the loader. =
Otherwise=20
<CODE>require</CODE> searches for a Lua loader using the path stored in =
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.path"><CODE=
>package.path</CODE></A>.=20
If that also fails, it searches for a C&nbsp;loader using the path =
stored in <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.cpath"><COD=
E>package.cpath</CODE></A>.=20
If that also fails, it tries an <EM>all-in-one</EM> loader (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.loaders"><C=
ODE>package.loaders</CODE></A>).=20

<P>Once a loader is found, <CODE>require</CODE> calls the loader with a =
single=20
argument, <CODE>modname</CODE>. If the loader returns any value,=20
<CODE>require</CODE> assigns the returned value to=20
<CODE>package.loaded[modname]</CODE>. If the loader returns no value and =
has not=20
assigned any value to <CODE>package.loaded[modname]</CODE>, then=20
<CODE>require</CODE> assigns <B>true</B> to this entry. In any case,=20
<CODE>require</CODE> returns the final value of=20
<CODE>package.loaded[modname]</CODE>.=20
<P>If there is any error loading or running the module, or if it cannot =
find any=20
loader for the module, then <CODE>require</CODE> signals an error.=20
<P>
<HR>

<H3><A name=3Dpdf-package.cpath><CODE>package.cpath</CODE></A></H3>
<P>The path used by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
to search for a C&nbsp;loader.=20
<P>Lua initializes the C&nbsp;path <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.cpath"><COD=
E>package.cpath</CODE></A>=20
in the same way it initializes the Lua path <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.path"><CODE=
>package.path</CODE></A>,=20
using the environment variable <A =
name=3Dpdf-LUA_CPATH><CODE>LUA_CPATH</CODE></A>=20
or a default path defined in <CODE>luaconf.h</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-package.loaded><CODE>package.loaded</CODE></A></H3>
<P>A table used by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
to control which modules are already loaded. When you require a module=20
<CODE>modname</CODE> and <CODE>package.loaded[modname]</CODE> is not =
false, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
simply returns the value stored there.=20
<P>
<HR>

<H3><A name=3Dpdf-package.loaders><CODE>package.loaders</CODE></A></H3>
<P>A table used by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
to control how to load modules.=20
<P>Each entry in this table is a <EM>searcher function</EM>. When =
looking for a=20
module, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
calls each of these searchers in ascending order, with the module name =
(the=20
argument given to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>)=20
as its sole parameter. The function can return another function (the =
module=20
<EM>loader</EM>) or a string explaining why it did not find that module =
(or=20
<B>nil</B> if it has nothing to say). Lua initializes this table with =
four=20
functions.=20
<P>The first searcher simply looks for a loader in the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.preload"><C=
ODE>package.preload</CODE></A>=20
table.=20
<P>The second searcher looks for a loader as a Lua library, using the =
path=20
stored at <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.path"><CODE=
>package.path</CODE></A>.=20
A path is a sequence of <EM>templates</EM> separated by semicolons. For =
each=20
template, the searcher will change each interrogation mark in the =
template by=20
<CODE>filename</CODE>, which is the module name with each dot replaced =
by a=20
"directory separator" (such as "<CODE>/</CODE>" in Unix); then it will =
try to=20
open the resulting file name. So, for instance, if the Lua path is the =
string <PRE>     "./?.lua;./?.lc;/usr/local/?/init.lua"
</PRE>
<P>the search for a Lua file for module <CODE>foo</CODE> will try to =
open the=20
files <CODE>./foo.lua</CODE>, <CODE>./foo.lc</CODE>, and=20
<CODE>/usr/local/foo/init.lua</CODE>, in that order.=20
<P>The third searcher looks for a loader as a C&nbsp;library, using the =
path=20
given by the variable <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.cpath"><COD=
E>package.cpath</CODE></A>.=20
For instance, if the C&nbsp;path is the string <PRE>     =
"./?.so;./?.dll;/usr/local/?/init.so"
</PRE>
<P>the searcher for module <CODE>foo</CODE> will try to open the files=20
<CODE>./foo.so</CODE>, <CODE>./foo.dll</CODE>, and=20
<CODE>/usr/local/foo/init.so</CODE>, in that order. Once it finds a=20
C&nbsp;library, this searcher first uses a dynamic link facility to link =
the=20
application with the library. Then it tries to find a C&nbsp;function =
inside the=20
library to be used as the loader. The name of this C&nbsp;function is =
the string=20
"<CODE>luaopen_</CODE>" concatenated with a copy of the module name =
where each=20
dot is replaced by an underscore. Moreover, if the module name has a =
hyphen, its=20
prefix up to (and including) the first hyphen is removed. For instance, =
if the=20
module name is <CODE>a.v1-b.c</CODE>, the function name will be=20
<CODE>luaopen_b_c</CODE>.=20
<P>The fourth searcher tries an <EM>all-in-one loader</EM>. It searches =
the=20
C&nbsp;path for a library for the root name of the given module. For =
instance,=20
when requiring <CODE>a.b.c</CODE>, it will search for a C&nbsp;library =
for=20
<CODE>a</CODE>. If found, it looks into it for an open function for the=20
submodule; in our example, that would be <CODE>luaopen_a_b_c</CODE>. =
With this=20
facility, a package can pack several C&nbsp;submodules into one single =
library,=20
with each submodule keeping its original open function.=20
<P>
<HR>

<H3><A name=3Dpdf-package.loadlib><CODE>package.loadlib (libname,=20
funcname)</CODE></A></H3>
<P>Dynamically links the host program with the C&nbsp;library=20
<CODE>libname</CODE>. Inside this library, looks for a function=20
<CODE>funcname</CODE> and returns this function as a C&nbsp;function. =
(So,=20
<CODE>funcname</CODE> must follow the protocol (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_CFunction"><CODE>lu=
a_CFunction</CODE></A>)).=20

<P>This is a low-level function. It completely bypasses the package and =
module=20
system. Unlike <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>,=20
it does not perform any path searching and does not automatically adds=20
extensions. <CODE>libname</CODE> must be the complete file name of the=20
C&nbsp;library, including if necessary a path and extension.=20
<CODE>funcname</CODE> must be the exact name exported by the =
C&nbsp;library=20
(which may depend on the C&nbsp;compiler and linker used).=20
<P>This function is not supported by ANSI C. As such, it is only =
available on=20
some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix =
systems=20
that support the <CODE>dlfcn</CODE> standard).=20
<P>
<HR>

<H3><A name=3Dpdf-package.path><CODE>package.path</CODE></A></H3>
<P>The path used by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
to search for a Lua loader.=20
<P>At start-up, Lua initializes this variable with the value of the =
environment=20
variable <A name=3Dpdf-LUA_PATH><CODE>LUA_PATH</CODE></A> or with a =
default path=20
defined in <CODE>luaconf.h</CODE>, if the environment variable is not =
defined.=20
Any "<CODE>;;</CODE>" in the value of the environment variable is =
replaced by=20
the default path.=20
<P>
<HR>

<H3><A name=3Dpdf-package.preload><CODE>package.preload</CODE></A></H3>
<P>A table to store loaders for specific modules (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>).=20

<P>
<HR>

<H3><A name=3Dpdf-package.seeall><CODE>package.seeall =
(module)</CODE></A></H3>
<P>Sets a metatable for <CODE>module</CODE> with its =
<CODE>__index</CODE> field=20
referring to the global environment, so that this module inherits values =
from=20
the global environment. To be used as an option to function <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-module"><CODE>modul=
e</CODE></A>.=20

<H2>5.4 - <A name=3D5.4>String Manipulation</A></H2>
<P>This library provides generic functions for string manipulation, such =
as=20
finding and extracting substrings, and pattern matching. When indexing a =
string=20
in Lua, the first character is at position&nbsp;1 (not at&nbsp;0, as in =
C).=20
Indices are allowed to be negative and are interpreted as indexing =
backwards,=20
from the end of the string. Thus, the last character is at position -1, =
and so=20
on.=20
<P>The string library provides all its functions inside the table <A=20
name=3Dpdf-string><CODE>string</CODE></A>. It also sets a metatable for =
strings=20
where the <CODE>__index</CODE> field points to the <CODE>string</CODE> =
table.=20
Therefore, you can use the string functions in object-oriented style. =
For=20
instance, <CODE>string.byte(s, i)</CODE> can be written as=20
<CODE>s:byte(i)</CODE>.=20
<P>The string library assumes one-byte character encodings.=20
<P>
<HR>

<H3><A name=3Dpdf-string.byte><CODE>string.byte (s [, i [,=20
j]])</CODE></A></H3>Returns the internal numerical codes of the =
characters=20
<CODE>s[i]</CODE>, <CODE>s[i+1]</CODE>, =B7=B7=B7, <CODE>s[j]</CODE>. =
The default=20
value for <CODE>i</CODE> is&nbsp;1; the default value for <CODE>j</CODE> =

is&nbsp;<CODE>i</CODE>.=20
<P>Note that numerical codes are not necessarily portable across =
platforms.=20
<P>
<HR>

<H3><A name=3Dpdf-string.char><CODE>string.char =
(=B7=B7=B7)</CODE></A></H3>Receives zero=20
or more integers. Returns a string with length equal to the number of =
arguments,=20
in which each character has the internal numerical code equal to its=20
corresponding argument.=20
<P>Note that numerical codes are not necessarily portable across =
platforms.=20
<P>
<HR>

<H3><A name=3Dpdf-string.dump><CODE>string.dump =
(function)</CODE></A></H3>
<P>Returns a string containing a binary representation of the given =
function, so=20
that a later <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-loadstring"><CODE>l=
oadstring</CODE></A>=20
on this string returns a copy of the function. <CODE>function</CODE> =
must be a=20
Lua function without upvalues.=20
<P>
<HR>

<H3><A name=3Dpdf-string.find><CODE>string.find (s, pattern [, init [,=20
plain]])</CODE></A></H3>Looks for the first match of =
<CODE>pattern</CODE> in the=20
string <CODE>s</CODE>. If it finds a match, then <CODE>find</CODE> =
returns the=20
indices of&nbsp;<CODE>s</CODE> where this occurrence starts and ends; =
otherwise,=20
it returns <B>nil</B>. A third, optional numerical argument =
<CODE>init</CODE>=20
specifies where to start the search; its default value is&nbsp;1 and can =
be=20
negative. A value of <B>true</B> as a fourth, optional argument=20
<CODE>plain</CODE> turns off the pattern matching facilities, so the =
function=20
does a plain "find substring" operation, with no characters in=20
<CODE>pattern</CODE> being considered "magic". Note that if =
<CODE>plain</CODE>=20
is given, then <CODE>init</CODE> must be given as well.=20
<P>If the pattern has captures, then in a successful match the captured =
values=20
are also returned, after the two indices.=20
<P>
<HR>

<H3><A name=3Dpdf-string.format><CODE>string.format (formatstring,=20
=B7=B7=B7)</CODE></A></H3>Returns a formatted version of its variable =
number of=20
arguments following the description given in its first argument (which =
must be a=20
string). The format string follows the same rules as the =
<CODE>printf</CODE>=20
family of standard C&nbsp;functions. The only differences are that the=20
options/modifiers <CODE>*</CODE>, <CODE>l</CODE>, <CODE>L</CODE>,=20
<CODE>n</CODE>, <CODE>p</CODE>, and <CODE>h</CODE> are not supported and =
that=20
there is an extra option, <CODE>q</CODE>. The <CODE>q</CODE> option =
formats a=20
string in a form suitable to be safely read back by the Lua interpreter: =
the=20
string is written between double quotes, and all double quotes, =
newlines,=20
embedded zeros, and backslashes in the string are correctly escaped when =

written. For instance, the call <PRE>     string.format('%q', 'a string =
with "quotes" and \n new line')
</PRE>
<P>will produce the string: <PRE>     "a string with \"quotes\" and \
      new line"
</PRE>
<P>The options <CODE>c</CODE>, <CODE>d</CODE>, <CODE>E</CODE>, =
<CODE>e</CODE>,=20
<CODE>f</CODE>, <CODE>g</CODE>, <CODE>G</CODE>, <CODE>i</CODE>, =
<CODE>o</CODE>,=20
<CODE>u</CODE>, <CODE>X</CODE>, and <CODE>x</CODE> all expect a number =
as=20
argument, whereas <CODE>q</CODE> and <CODE>s</CODE> expect a string.=20
<P>This function does not accept string values containing embedded =
zeros, except=20
as arguments to the <CODE>q</CODE> option.=20
<P>
<HR>

<H3><A name=3Dpdf-string.gmatch><CODE>string.gmatch (s,=20
pattern)</CODE></A></H3>Returns an iterator function that, each time it =
is=20
called, returns the next captures from <CODE>pattern</CODE> over string=20
<CODE>s</CODE>. If <CODE>pattern</CODE> specifies no captures, then the =
whole=20
match is produced in each call.=20
<P>As an example, the following loop <PRE>     s =3D "hello world from =
Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</PRE>
<P>will iterate over all the words from string <CODE>s</CODE>, printing =
one per=20
line. The next example collects all pairs <CODE>key=3Dvalue</CODE> from =
the given=20
string into a table: <PRE>     t =3D {}
     s =3D "from=3Dworld, to=3DLua"
     for k, v in string.gmatch(s, "(%w+)=3D(%w+)") do
       t[k] =3D v
     end
</PRE>
<P>For this function, a '<CODE>^</CODE>' at the start of a pattern does =
not work=20
as an anchor, as this would prevent the iteration.=20
<P>
<HR>

<H3><A name=3Dpdf-string.gsub><CODE>string.gsub (s, pattern, repl [,=20
n])</CODE></A></H3>Returns a copy of <CODE>s</CODE> in which all (or the =
first=20
<CODE>n</CODE>, if given) occurrences of the <CODE>pattern</CODE> have =
been=20
replaced by a replacement string specified by <CODE>repl</CODE>, which =
can be a=20
string, a table, or a function. <CODE>gsub</CODE> also returns, as its =
second=20
value, the total number of matches that occurred.=20
<P>If <CODE>repl</CODE> is a string, then its value is used for =
replacement. The=20
character&nbsp;<CODE>%</CODE> works as an escape character: any sequence =
in=20
<CODE>repl</CODE> of the form <CODE>%<EM>n</EM></CODE>, with <EM>n</EM> =
between=20
1 and 9, stands for the value of the <EM>n</EM>-th captured substring =
(see=20
below). The sequence <CODE>%0</CODE> stands for the whole match. The =
sequence=20
<CODE>%%</CODE> stands for a single&nbsp;<CODE>%</CODE>.=20
<P>If <CODE>repl</CODE> is a table, then the table is queried for every =
match,=20
using the first capture as the key; if the pattern specifies no =
captures, then=20
the whole match is used as the key.=20
<P>If <CODE>repl</CODE> is a function, then this function is called =
every time a=20
match occurs, with all captured substrings passed as arguments, in =
order; if the=20
pattern specifies no captures, then the whole match is passed as a sole=20
argument.=20
<P>If the value returned by the table query or by the function call is a =
string=20
or a number, then it is used as the replacement string; otherwise, if it =
is=20
<B>false</B> or <B>nil</B>, then there is no replacement (that is, the =
original=20
match is kept in the string).=20
<P>Here are some examples: <PRE>     x =3D string.gsub("hello world", =
"(%w+)", "%1 %1")
     --&gt; x=3D"hello hello world world"
    =20
     x =3D string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x=3D"hello hello world"
    =20
     x =3D string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x=3D"world hello Lua from"
    =20
     x =3D string.gsub("home =3D $HOME, user =3D $USER", "%$(%w+)", =
os.getenv)
     --&gt; x=3D"home =3D /home/roberto, user =3D roberto"
    =20
     x =3D string.gsub("4+5 =3D $return 4+5$", "%$(.-)%$", function (s)
           return loadstring(s)()
         end)
     --&gt; x=3D"4+5 =3D 9"
    =20
     local t =3D {name=3D"lua", version=3D"5.1"}
     x =3D string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x=3D"lua-5.1.tar.gz"
</PRE>
<P>
<HR>

<H3><A name=3Dpdf-string.len><CODE>string.len =
(s)</CODE></A></H3>Receives a string=20
and returns its length. The empty string <CODE>""</CODE> has length 0. =
Embedded=20
zeros are counted, so <CODE>"a\000bc\000"</CODE> has length 5.=20
<P>
<HR>

<H3><A name=3Dpdf-string.lower><CODE>string.lower =
(s)</CODE></A></H3>Receives a=20
string and returns a copy of this string with all uppercase letters =
changed to=20
lowercase. All other characters are left unchanged. The definition of =
what an=20
uppercase letter is depends on the current locale.=20
<P>
<HR>

<H3><A name=3Dpdf-string.match><CODE>string.match (s, pattern [,=20
init])</CODE></A></H3>Looks for the first <EM>match</EM> of =
<CODE>pattern</CODE>=20
in the string <CODE>s</CODE>. If it finds one, then <CODE>match</CODE> =
returns=20
the captures from the pattern; otherwise it returns <B>nil</B>. If=20
<CODE>pattern</CODE> specifies no captures, then the whole match is =
returned. A=20
third, optional numerical argument <CODE>init</CODE> specifies where to =
start=20
the search; its default value is&nbsp;1 and can be negative.=20
<P>
<HR>

<H3><A name=3Dpdf-string.rep><CODE>string.rep (s, =
n)</CODE></A></H3>Returns a=20
string that is the concatenation of <CODE>n</CODE> copies of the string=20
<CODE>s</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-string.reverse><CODE>string.reverse =
(s)</CODE></A></H3>Returns a=20
string that is the string <CODE>s</CODE> reversed.=20
<P>
<HR>

<H3><A name=3Dpdf-string.sub><CODE>string.sub (s, i [, =
j])</CODE></A></H3>Returns=20
the substring of <CODE>s</CODE> that starts at <CODE>i</CODE> and =
continues=20
until <CODE>j</CODE>; <CODE>i</CODE> and <CODE>j</CODE> can be negative. =
If=20
<CODE>j</CODE> is absent, then it is assumed to be equal to -1 (which is =
the=20
same as the string length). In particular, the call=20
<CODE>string.sub(s,1,j)</CODE> returns a prefix of <CODE>s</CODE> with =
length=20
<CODE>j</CODE>, and <CODE>string.sub(s, -i)</CODE> returns a suffix of=20
<CODE>s</CODE> with length <CODE>i</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-string.upper><CODE>string.upper =
(s)</CODE></A></H3>Receives a=20
string and returns a copy of this string with all lowercase letters =
changed to=20
uppercase. All other characters are left unchanged. The definition of =
what a=20
lowercase letter is depends on the current locale.=20
<H3>5.4.1 - <A name=3D5.4.1>Patterns</A></H3>
<H4>Character Class:</H4>
<P>A <EM>character class</EM> is used to represent a set of characters. =
The=20
following combinations are allowed in describing a character class:=20
<UL>
  <LI><B><EM>x</EM>:</B> (where <EM>x</EM> is not one of the <EM>magic=20
  characters</EM> <CODE>^$()%.[]*+-?</CODE>) represents the character =
<EM>x</EM>=20
  itself.=20
  <LI><B><CODE>.</CODE>:</B> (a dot) represents all characters.=20
  <LI><B><CODE>%a</CODE>:</B> represents all letters.=20
  <LI><B><CODE>%c</CODE>:</B> represents all control characters.=20
  <LI><B><CODE>%d</CODE>:</B> represents all digits.=20
  <LI><B><CODE>%l</CODE>:</B> represents all lowercase letters.=20
  <LI><B><CODE>%p</CODE>:</B> represents all punctuation characters.=20
  <LI><B><CODE>%s</CODE>:</B> represents all space characters.=20
  <LI><B><CODE>%u</CODE>:</B> represents all uppercase letters.=20
  <LI><B><CODE>%w</CODE>:</B> represents all alphanumeric characters.=20
  <LI><B><CODE>%x</CODE>:</B> represents all hexadecimal digits.=20
  <LI><B><CODE>%z</CODE>:</B> represents the character with =
representation 0.=20
  <LI><B><CODE>%<EM>x</EM></CODE>:</B> (where <EM>x</EM> is any =
non-alphanumeric=20
  character) represents the character <EM>x</EM>. This is the standard =
way to=20
  escape the magic characters. Any punctuation character (even the non =
magic)=20
  can be preceded by a '<CODE>%</CODE>' when used to represent itself in =
a=20
  pattern.=20
  <LI><B><CODE>[<EM>set</EM>]</CODE>:</B> represents the class which is =
the=20
  union of all characters in <EM>set</EM>. A range of characters can be=20
  specified by separating the end characters of the range with a=20
  '<CODE>-</CODE>'. All classes <CODE>%</CODE><EM>x</EM> described above =
can=20
  also be used as components in <EM>set</EM>. All other characters in=20
  <EM>set</EM> represent themselves. For example, <CODE>[%w_]</CODE> (or =

  <CODE>[_%w]</CODE>) represents all alphanumeric characters plus the=20
  underscore, <CODE>[0-7]</CODE> represents the octal digits, and=20
  <CODE>[0-7%l%-]</CODE> represents the octal digits plus the lowercase =
letters=20
  plus the '<CODE>-</CODE>' character.=20
  <P>The interaction between ranges and classes is not defined. =
Therefore,=20
  patterns like <CODE>[%a-z]</CODE> or <CODE>[a-%%]</CODE> have no =
meaning. </P>
  <LI><B><CODE>[^<EM>set</EM>]</CODE>:</B> represents the complement of=20
  <EM>set</EM>, where <EM>set</EM> is interpreted as above. </LI></UL>
<P>For all classes represented by single letters (<CODE>%a</CODE>,=20
<CODE>%c</CODE>, etc.), the corresponding uppercase letter represents =
the=20
complement of the class. For instance, <CODE>%S</CODE> represents all =
non-space=20
characters.=20
<P>The definitions of letter, space, and other character groups depend =
on the=20
current locale. In particular, the class <CODE>[a-z]</CODE> may not be=20
equivalent to <CODE>%l</CODE>.=20
<H4>Pattern Item:</H4>
<P>A <EM>pattern item</EM> can be=20
<UL>
  <LI>a single character class, which matches any single character in =
the class;=20

  <LI>a single character class followed by '<CODE>*</CODE>', which =
matches 0 or=20
  more repetitions of characters in the class. These repetition items =
will=20
  always match the longest possible sequence;=20
  <LI>a single character class followed by '<CODE>+</CODE>', which =
matches 1 or=20
  more repetitions of characters in the class. These repetition items =
will=20
  always match the longest possible sequence;=20
  <LI>a single character class followed by '<CODE>-</CODE>', which also =
matches=20
  0 or more repetitions of characters in the class. Unlike =
'<CODE>*</CODE>',=20
  these repetition items will always match the <EM>shortest</EM> =
possible=20
  sequence;=20
  <LI>a single character class followed by '<CODE>?</CODE>', which =
matches 0 or=20
  1 occurrence of a character in the class;=20
  <LI><CODE>%<EM>n</EM></CODE>, for <EM>n</EM> between 1 and 9; such =
item=20
  matches a substring equal to the <EM>n</EM>-th captured string (see =
below);=20
  <LI><CODE>%b<EM>xy</EM></CODE>, where <EM>x</EM> and <EM>y</EM> are =
two=20
  distinct characters; such item matches strings that start=20
  with&nbsp;<EM>x</EM>, end with&nbsp;<EM>y</EM>, and where the =
<EM>x</EM> and=20
  <EM>y</EM> are <EM>balanced</EM>. This means that, if one reads the =
string=20
  from left to right, counting <EM>+1</EM> for an <EM>x</EM> and =
<EM>-1</EM> for=20
  a <EM>y</EM>, the ending <EM>y</EM> is the first <EM>y</EM> where the =
count=20
  reaches 0. For instance, the item <CODE>%b()</CODE> matches =
expressions with=20
  balanced parentheses. </LI></UL>
<H4>Pattern:</H4>
<P>A <EM>pattern</EM> is a sequence of pattern items. A '<CODE>^</CODE>' =
at the=20
beginning of a pattern anchors the match at the beginning of the subject =
string.=20
A '<CODE>$</CODE>' at the end of a pattern anchors the match at the end =
of the=20
subject string. At other positions, '<CODE>^</CODE>' and =
'<CODE>$</CODE>' have=20
no special meaning and represent themselves.=20
<H4>Captures:</H4>
<P>A pattern can contain sub-patterns enclosed in parentheses; they =
describe=20
<EM>captures</EM>. When a match succeeds, the substrings of the subject =
string=20
that match captures are stored (<EM>captured</EM>) for future use. =
Captures are=20
numbered according to their left parentheses. For instance, in the =
pattern=20
<CODE>"(a*(.)%w(%s*))"</CODE>, the part of the string matching=20
<CODE>"a*(.)%w(%s*)"</CODE> is stored as the first capture (and =
therefore has=20
number&nbsp;1); the character matching "<CODE>.</CODE>" is captured with =

number&nbsp;2, and the part matching "<CODE>%s*</CODE>" has =
number&nbsp;3.=20
<P>As a special case, the empty capture <CODE>()</CODE> captures the =
current=20
string position (a number). For instance, if we apply the pattern=20
<CODE>"()aa()"</CODE> on the string <CODE>"flaaap"</CODE>, there will be =
two=20
captures: 3&nbsp;and&nbsp;5.=20
<P>A pattern cannot contain embedded zeros. Use <CODE>%z</CODE> instead. =

<H2>5.5 - <A name=3D5.5>Table Manipulation</A></H2>
<P>This library provides generic functions for table manipulation. It =
provides=20
all its functions inside the table <A =
name=3Dpdf-table><CODE>table</CODE></A>.=20
<P>Most functions in the table library assume that the table represents =
an array=20
or a list. For these functions, when we talk about the "length" of a =
table we=20
mean the result of the length operator.=20
<P>
<HR>

<H3><A name=3Dpdf-table.concat><CODE>table.concat (table [, sep [, i [,=20
j]]])</CODE></A></H3>Given an array where all elements are strings or =
numbers,=20
returns <CODE>table[i]..sep..table[i+1] =B7=B7=B7 sep..table[j]</CODE>. =
The default=20
value for <CODE>sep</CODE> is the empty string, the default for =
<CODE>i</CODE>=20
is 1, and the default for <CODE>j</CODE> is the length of the table. If=20
<CODE>i</CODE> is greater than <CODE>j</CODE>, returns the empty string. =

<P>
<HR>

<H3><A name=3Dpdf-table.insert><CODE>table.insert (table, [pos,]=20
value)</CODE></A></H3>
<P>Inserts element <CODE>value</CODE> at position <CODE>pos</CODE> in=20
<CODE>table</CODE>, shifting up other elements to open space, if =
necessary. The=20
default value for <CODE>pos</CODE> is <CODE>n+1</CODE>, where =
<CODE>n</CODE> is=20
the length of the table (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#2.5.5">=A72.5.5</A>), =
so that a=20
call <CODE>table.insert(t,x)</CODE> inserts <CODE>x</CODE> at the end of =
table=20
<CODE>t</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-table.maxn><CODE>table.maxn (table)</CODE></A></H3>
<P>Returns the largest positive numerical index of the given table, or =
zero if=20
the table has no positive numerical indices. (To do its job this =
function does a=20
linear traversal of the whole table.)=20
<P>
<HR>

<H3><A name=3Dpdf-table.remove><CODE>table.remove (table [, =
pos])</CODE></A></H3>
<P>Removes from <CODE>table</CODE> the element at position =
<CODE>pos</CODE>,=20
shifting down other elements to close the space, if necessary. Returns =
the value=20
of the removed element. The default value for <CODE>pos</CODE> is=20
<CODE>n</CODE>, where <CODE>n</CODE> is the length of the table, so that =
a call=20
<CODE>table.remove(t)</CODE> removes the last element of table =
<CODE>t</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-table.sort><CODE>table.sort (table [,=20
comp])</CODE></A></H3>Sorts table elements in a given order, =
<EM>in-place</EM>,=20
from <CODE>table[1]</CODE> to <CODE>table[n]</CODE>, where =
<CODE>n</CODE> is the=20
length of the table. If <CODE>comp</CODE> is given, then it must be a =
function=20
that receives two table elements, and returns true when the first is =
less than=20
the second (so that <CODE>not comp(a[i+1],a[i])</CODE> will be true =
after the=20
sort). If <CODE>comp</CODE> is not given, then the standard Lua operator =

<CODE>&lt;</CODE> is used instead.=20
<P>The sort algorithm is not stable; that is, elements considered equal =
by the=20
given order may have their relative positions changed by the sort.=20
<H2>5.6 - <A name=3D5.6>Mathematical Functions</A></H2>
<P>This library is an interface to the standard C&nbsp;math library. It =
provides=20
all its functions inside the table <A =
name=3Dpdf-math><CODE>math</CODE></A>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.abs><CODE>math.abs (x)</CODE></A></H3>
<P>Returns the absolute value of <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.acos><CODE>math.acos (x)</CODE></A></H3>
<P>Returns the arc cosine of <CODE>x</CODE> (in radians).=20
<P>
<HR>

<H3><A name=3Dpdf-math.asin><CODE>math.asin (x)</CODE></A></H3>
<P>Returns the arc sine of <CODE>x</CODE> (in radians).=20
<P>
<HR>

<H3><A name=3Dpdf-math.atan><CODE>math.atan (x)</CODE></A></H3>
<P>Returns the arc tangent of <CODE>x</CODE> (in radians).=20
<P>
<HR>

<H3><A name=3Dpdf-math.atan2><CODE>math.atan2 (y, x)</CODE></A></H3>
<P>Returns the arc tangent of <CODE>y/x</CODE> (in radians), but uses =
the signs=20
of both parameters to find the quadrant of the result. (It also handles=20
correctly the case of <CODE>x</CODE> being zero.)=20
<P>
<HR>

<H3><A name=3Dpdf-math.ceil><CODE>math.ceil (x)</CODE></A></H3>
<P>Returns the smallest integer larger than or equal to <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.cos><CODE>math.cos (x)</CODE></A></H3>
<P>Returns the cosine of <CODE>x</CODE> (assumed to be in radians).=20
<P>
<HR>

<H3><A name=3Dpdf-math.cosh><CODE>math.cosh (x)</CODE></A></H3>
<P>Returns the hyperbolic cosine of <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.deg><CODE>math.deg (x)</CODE></A></H3>
<P>Returns the angle <CODE>x</CODE> (given in radians) in degrees.=20
<P>
<HR>

<H3><A name=3Dpdf-math.exp><CODE>math.exp (x)</CODE></A></H3>
<P>Returns the value <EM>e<SUP>x</SUP></EM>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.floor><CODE>math.floor (x)</CODE></A></H3>
<P>Returns the largest integer smaller than or equal to <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.fmod><CODE>math.fmod (x, y)</CODE></A></H3>
<P>Returns the remainder of the division of <CODE>x</CODE> by =
<CODE>y</CODE>=20
that rounds the quotient towards zero.=20
<P>
<HR>

<H3><A name=3Dpdf-math.frexp><CODE>math.frexp (x)</CODE></A></H3>
<P>Returns <CODE>m</CODE> and <CODE>e</CODE> such that <EM>x =3D=20
m2<SUP>e</SUP></EM>, <CODE>e</CODE> is an integer and the absolute value =
of=20
<CODE>m</CODE> is in the range <EM>[0.5, 1)</EM> (or zero when =
<CODE>x</CODE> is=20
zero).=20
<P>
<HR>

<H3><A name=3Dpdf-math.huge><CODE>math.huge</CODE></A></H3>
<P>The value <CODE>HUGE_VAL</CODE>, a value larger than or equal to any =
other=20
numerical value.=20
<P>
<HR>

<H3><A name=3Dpdf-math.ldexp><CODE>math.ldexp (m, e)</CODE></A></H3>
<P>Returns <EM>m2<SUP>e</SUP></EM> (<CODE>e</CODE> should be an =
integer).=20
<P>
<HR>

<H3><A name=3Dpdf-math.log><CODE>math.log (x)</CODE></A></H3>
<P>Returns the natural logarithm of <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.log10><CODE>math.log10 (x)</CODE></A></H3>
<P>Returns the base-10 logarithm of <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.max><CODE>math.max (x, =B7=B7=B7)</CODE></A></H3>
<P>Returns the maximum value among its arguments.=20
<P>
<HR>

<H3><A name=3Dpdf-math.min><CODE>math.min (x, =B7=B7=B7)</CODE></A></H3>
<P>Returns the minimum value among its arguments.=20
<P>
<HR>

<H3><A name=3Dpdf-math.modf><CODE>math.modf (x)</CODE></A></H3>
<P>Returns two numbers, the integral part of <CODE>x</CODE> and the =
fractional=20
part of <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.pi><CODE>math.pi</CODE></A></H3>
<P>The value of <EM>pi</EM>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.pow><CODE>math.pow (x, y)</CODE></A></H3>
<P>Returns <EM>x<SUP>y</SUP></EM>. (You can also use the expression=20
<CODE>x^y</CODE> to compute this value.)=20
<P>
<HR>

<H3><A name=3Dpdf-math.rad><CODE>math.rad (x)</CODE></A></H3>
<P>Returns the angle <CODE>x</CODE> (given in degrees) in radians.=20
<P>
<HR>

<H3><A name=3Dpdf-math.random><CODE>math.random ([m [, =
n]])</CODE></A></H3>
<P>This function is an interface to the simple pseudo-random generator =
function=20
<CODE>rand</CODE> provided by ANSI&nbsp;C. (No guarantees can be given =
for its=20
statistical properties.)=20
<P>When called without arguments, returns a uniform pseudo-random real =
number in=20
the range <EM>[0,1)</EM>. When called with an integer number =
<CODE>m</CODE>,=20
<CODE>math.random</CODE> returns a uniform pseudo-random integer in the =
range=20
<EM>[1, m]</EM>. When called with two integer numbers <CODE>m</CODE> and =

<CODE>n</CODE>, <CODE>math.random</CODE> returns a uniform pseudo-random =
integer=20
in the range <EM>[m, n]</EM>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.randomseed><CODE>math.randomseed =
(x)</CODE></A></H3>
<P>Sets <CODE>x</CODE> as the "seed" for the pseudo-random generator: =
equal=20
seeds produce equal sequences of numbers.=20
<P>
<HR>

<H3><A name=3Dpdf-math.sin><CODE>math.sin (x)</CODE></A></H3>
<P>Returns the sine of <CODE>x</CODE> (assumed to be in radians).=20
<P>
<HR>

<H3><A name=3Dpdf-math.sinh><CODE>math.sinh (x)</CODE></A></H3>
<P>Returns the hyperbolic sine of <CODE>x</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-math.sqrt><CODE>math.sqrt (x)</CODE></A></H3>
<P>Returns the square root of <CODE>x</CODE>. (You can also use the =
expression=20
<CODE>x^0.5</CODE> to compute this value.)=20
<P>
<HR>

<H3><A name=3Dpdf-math.tan><CODE>math.tan (x)</CODE></A></H3>
<P>Returns the tangent of <CODE>x</CODE> (assumed to be in radians).=20
<P>
<HR>

<H3><A name=3Dpdf-math.tanh><CODE>math.tanh (x)</CODE></A></H3>
<P>Returns the hyperbolic tangent of <CODE>x</CODE>.=20
<H2>5.7 - <A name=3D5.7>Input and Output Facilities</A></H2>
<P>The I/O library provides two different styles for file manipulation. =
The=20
first one uses implicit file descriptors; that is, there are operations =
to set a=20
default input file and a default output file, and all input/output =
operations=20
are over these default files. The second style uses explicit file =
descriptors.=20
<P>When using implicit file descriptors, all operations are supplied by =
table <A=20
name=3Dpdf-io><CODE>io</CODE></A>. When using explicit file descriptors, =
the=20
operation <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-io.open"><CODE>io.o=
pen</CODE></A>=20
returns a file descriptor and then all operations are supplied as =
methods of the=20
file descriptor.=20
<P>The table <CODE>io</CODE> also provides three predefined file =
descriptors=20
with their usual meanings from C: <A=20
name=3Dpdf-io.stdin><CODE>io.stdin</CODE></A>, <A=20
name=3Dpdf-io.stdout><CODE>io.stdout</CODE></A>, and <A=20
name=3Dpdf-io.stderr><CODE>io.stderr</CODE></A>. The I/O library never =
closes=20
these files.=20
<P>Unless otherwise stated, all I/O functions return <B>nil</B> on =
failure (plus=20
an error message as a second result and a system-dependent error code as =
a third=20
result) and some value different from <B>nil</B> on success.=20
<P>
<HR>

<H3><A name=3Dpdf-io.close><CODE>io.close ([file])</CODE></A></H3>
<P>Equivalent to <CODE>file:close()</CODE>. Without a <CODE>file</CODE>, =
closes=20
the default output file.=20
<P>
<HR>

<H3><A name=3Dpdf-io.flush><CODE>io.flush ()</CODE></A></H3>
<P>Equivalent to <CODE>file:flush</CODE> over the default output file.=20
<P>
<HR>

<H3><A name=3Dpdf-io.input><CODE>io.input ([file])</CODE></A></H3>
<P>When called with a file name, it opens the named file (in text mode), =
and=20
sets its handle as the default input file. When called with a file =
handle, it=20
simply sets this file handle as the default input file. When called =
without=20
parameters, it returns the current default input file.=20
<P>In case of errors this function raises the error, instead of =
returning an=20
error code.=20
<P>
<HR>

<H3><A name=3Dpdf-io.lines><CODE>io.lines ([filename])</CODE></A></H3>
<P>Opens the given file name in read mode and returns an iterator =
function that,=20
each time it is called, returns a new line from the file. Therefore, the =

construction <PRE>     for line in io.lines(filename) do <EM>body</EM> =
end
</PRE>
<P>will iterate over all lines of the file. When the iterator function =
detects=20
the end of file, it returns <B>nil</B> (to finish the loop) and =
automatically=20
closes the file.=20
<P>The call <CODE>io.lines()</CODE> (with no file name) is equivalent to =

<CODE>io.input():lines()</CODE>; that is, it iterates over the lines of =
the=20
default input file. In this case it does not close the file when the =
loop ends.=20
<P>
<HR>

<H3><A name=3Dpdf-io.open><CODE>io.open (filename [, =
mode])</CODE></A></H3>
<P>This function opens a file, in the mode specified in the string=20
<CODE>mode</CODE>. It returns a new file handle, or, in case of errors,=20
<B>nil</B> plus an error message.=20
<P>The <CODE>mode</CODE> string can be any of the following:=20
<UL>
  <LI><B>"r":</B> read mode (the default);=20
  <LI><B>"w":</B> write mode;=20
  <LI><B>"a":</B> append mode;=20
  <LI><B>"r+":</B> update mode, all previous data is preserved;=20
  <LI><B>"w+":</B> update mode, all previous data is erased;=20
  <LI><B>"a+":</B> append update mode, previous data is preserved, =
writing is=20
  only allowed at the end of file. </LI></UL>
<P>The <CODE>mode</CODE> string can also have a '<CODE>b</CODE>' at the =
end,=20
which is needed in some systems to open the file in binary mode. This =
string is=20
exactly what is used in the standard&nbsp;C function <CODE>fopen</CODE>. =

<P>
<HR>

<H3><A name=3Dpdf-io.output><CODE>io.output ([file])</CODE></A></H3>
<P>Similar to <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-io.input"><CODE>io.=
input</CODE></A>,=20
but operates over the default output file.=20
<P>
<HR>

<H3><A name=3Dpdf-io.popen><CODE>io.popen (prog [, =
mode])</CODE></A></H3>
<P>Starts program <CODE>prog</CODE> in a separated process and returns a =
file=20
handle that you can use to read data from this program (if =
<CODE>mode</CODE> is=20
<CODE>"r"</CODE>, the default) or to write data to this program (if=20
<CODE>mode</CODE> is <CODE>"w"</CODE>).=20
<P>This function is system dependent and is not available on all =
platforms.=20
<P>
<HR>

<H3><A name=3Dpdf-io.read><CODE>io.read (=B7=B7=B7)</CODE></A></H3>
<P>Equivalent to <CODE>io.input():read</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-io.tmpfile><CODE>io.tmpfile ()</CODE></A></H3>
<P>Returns a handle for a temporary file. This file is opened in update =
mode and=20
it is automatically removed when the program ends.=20
<P>
<HR>

<H3><A name=3Dpdf-io.type><CODE>io.type (obj)</CODE></A></H3>
<P>Checks whether <CODE>obj</CODE> is a valid file handle. Returns the =
string=20
<CODE>"file"</CODE> if <CODE>obj</CODE> is an open file handle, =
<CODE>"closed=20
file"</CODE> if <CODE>obj</CODE> is a closed file handle, or <B>nil</B> =
if=20
<CODE>obj</CODE> is not a file handle.=20
<P>
<HR>

<H3><A name=3Dpdf-io.write><CODE>io.write (=B7=B7=B7)</CODE></A></H3>
<P>Equivalent to <CODE>io.output():write</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-file:close><CODE>file:close ()</CODE></A></H3>
<P>Closes <CODE>file</CODE>. Note that files are automatically closed =
when their=20
handles are garbage collected, but that takes an unpredictable amount of =
time to=20
happen.=20
<P>
<HR>

<H3><A name=3Dpdf-file:flush><CODE>file:flush ()</CODE></A></H3>
<P>Saves any written data to <CODE>file</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-file:lines><CODE>file:lines ()</CODE></A></H3>
<P>Returns an iterator function that, each time it is called, returns a =
new line=20
from the file. Therefore, the construction <PRE>     for line in =
file:lines() do <EM>body</EM> end
</PRE>
<P>will iterate over all lines of the file. (Unlike <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-io.lines"><CODE>io.=
lines</CODE></A>,=20
this function does not close the file when the loop ends.)=20
<P>
<HR>

<H3><A name=3Dpdf-file:read><CODE>file:read (=B7=B7=B7)</CODE></A></H3>
<P>Reads the file <CODE>file</CODE>, according to the given formats, =
which=20
specify what to read. For each format, the function returns a string (or =
a=20
number) with the characters read, or <B>nil</B> if it cannot read data =
with the=20
specified format. When called without formats, it uses a default format =
that=20
reads the entire next line (see below).=20
<P>The available formats are=20
<UL>
  <LI><B>"*n":</B> reads a number; this is the only format that returns =
a number=20
  instead of a string.=20
  <LI><B>"*a":</B> reads the whole file, starting at the current =
position. On=20
  end of file, it returns the empty string.=20
  <LI><B>"*l":</B> reads the next line (skipping the end of line), =
returning=20
  <B>nil</B> on end of file. This is the default format.=20
  <LI><B><EM>number</EM>:</B> reads a string with up to this number of=20
  characters, returning <B>nil</B> on end of file. If number is zero, it =
reads=20
  nothing and returns an empty string, or <B>nil</B> on end of file. =
</LI></UL>
<P>
<HR>

<H3><A name=3Dpdf-file:seek><CODE>file:seek ([whence] [, =
offset])</CODE></A></H3>
<P>Sets and gets the file position, measured from the beginning of the =
file, to=20
the position given by <CODE>offset</CODE> plus a base specified by the =
string=20
<CODE>whence</CODE>, as follows:=20
<UL>
  <LI><B>"set":</B> base is position 0 (beginning of the file);=20
  <LI><B>"cur":</B> base is current position;=20
  <LI><B>"end":</B> base is end of file; </LI></UL>
<P>In case of success, function <CODE>seek</CODE> returns the final file =

position, measured in bytes from the beginning of the file. If this =
function=20
fails, it returns <B>nil</B>, plus a string describing the error.=20
<P>The default value for <CODE>whence</CODE> is <CODE>"cur"</CODE>, and =
for=20
<CODE>offset</CODE> is 0. Therefore, the call <CODE>file:seek()</CODE> =
returns=20
the current file position, without changing it; the call=20
<CODE>file:seek("set")</CODE> sets the position to the beginning of the =
file=20
(and returns 0); and the call <CODE>file:seek("end")</CODE> sets the =
position to=20
the end of the file, and returns its size.=20
<P>
<HR>

<H3><A name=3Dpdf-file:setvbuf><CODE>file:setvbuf (mode [, =
size])</CODE></A></H3>
<P>Sets the buffering mode for an output file. There are three available =
modes:=20
<UL>
  <LI><B>"no":</B> no buffering; the result of any output operation =
appears=20
  immediately.=20
  <LI><B>"full":</B> full buffering; output operation is performed only =
when the=20
  buffer is full (or when you explicitly <CODE>flush</CODE> the file =
(see <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-io.flush"><CODE>io.=
flush</CODE></A>)).=20

  <LI><B>"line":</B> line buffering; output is buffered until a newline =
is=20
  output or there is any input from some special files (such as a =
terminal=20
  device). </LI></UL>
<P>For the last two cases, <CODE>size</CODE> specifies the size of the =
buffer,=20
in bytes. The default is an appropriate size.=20
<P>
<HR>

<H3><A name=3Dpdf-file:write><CODE>file:write =
(=B7=B7=B7)</CODE></A></H3>
<P>Writes the value of each of its arguments to the <CODE>file</CODE>. =
The=20
arguments must be strings or numbers. To write other values, use <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-tostring"><CODE>tos=
tring</CODE></A>=20
or <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-string.format"><COD=
E>string.format</CODE></A>=20
before <CODE>write</CODE>.=20
<H2>5.8 - <A name=3D5.8>Operating System Facilities</A></H2>
<P>This library is implemented through table <A =
name=3Dpdf-os><CODE>os</CODE></A>.=20

<P>
<HR>

<H3><A name=3Dpdf-os.clock><CODE>os.clock ()</CODE></A></H3>
<P>Returns an approximation of the amount in seconds of CPU time used by =
the=20
program.=20
<P>
<HR>

<H3><A name=3Dpdf-os.date><CODE>os.date ([format [, =
time]])</CODE></A></H3>
<P>Returns a string or a table containing date and time, formatted =
according to=20
the given string <CODE>format</CODE>.=20
<P>If the <CODE>time</CODE> argument is present, this is the time to be=20
formatted (see the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-os.time"><CODE>os.t=
ime</CODE></A>=20
function for a description of this value). Otherwise, <CODE>date</CODE> =
formats=20
the current time.=20
<P>If <CODE>format</CODE> starts with '<CODE>!</CODE>', then the date is =

formatted in Coordinated Universal Time. After this optional character, =
if=20
<CODE>format</CODE> is the string "<CODE>*t</CODE>", then =
<CODE>date</CODE>=20
returns a table with the following fields: <CODE>year</CODE> (four =
digits),=20
<CODE>month</CODE> (1--12), <CODE>day</CODE> (1--31), <CODE>hour</CODE> =
(0--23),=20
<CODE>min</CODE> (0--59), <CODE>sec</CODE> (0--61), <CODE>wday</CODE> =
(weekday,=20
Sunday is&nbsp;1), <CODE>yday</CODE> (day of the year), and =
<CODE>isdst</CODE>=20
(daylight saving flag, a boolean).=20
<P>If <CODE>format</CODE> is not "<CODE>*t</CODE>", then =
<CODE>date</CODE>=20
returns the date as a string, formatted according to the same rules as =
the=20
C&nbsp;function <CODE>strftime</CODE>.=20
<P>When called without arguments, <CODE>date</CODE> returns a reasonable =
date=20
and time representation that depends on the host system and on the =
current=20
locale (that is, <CODE>os.date()</CODE> is equivalent to=20
<CODE>os.date("%c")</CODE>).=20
<P>
<HR>

<H3><A name=3Dpdf-os.difftime><CODE>os.difftime (t2, t1)</CODE></A></H3>
<P>Returns the number of seconds from time <CODE>t1</CODE> to time=20
<CODE>t2</CODE>. In POSIX, Windows, and some other systems, this value =
is=20
exactly <CODE>t2</CODE><EM>-</EM><CODE>t1</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-os.execute><CODE>os.execute =
([command])</CODE></A></H3>
<P>This function is equivalent to the C&nbsp;function =
<CODE>system</CODE>. It=20
passes <CODE>command</CODE> to be executed by an operating system shell. =
It=20
returns a status code, which is system-dependent. If =
<CODE>command</CODE> is=20
absent, then it returns nonzero if a shell is available and zero =
otherwise.=20
<P>
<HR>

<H3><A name=3Dpdf-os.exit><CODE>os.exit ([code])</CODE></A></H3>
<P>Calls the C&nbsp;function <CODE>exit</CODE>, with an optional=20
<CODE>code</CODE>, to terminate the host program. The default value for=20
<CODE>code</CODE> is the success code.=20
<P>
<HR>

<H3><A name=3Dpdf-os.getenv><CODE>os.getenv (varname)</CODE></A></H3>
<P>Returns the value of the process environment variable =
<CODE>varname</CODE>,=20
or <B>nil</B> if the variable is not defined.=20
<P>
<HR>

<H3><A name=3Dpdf-os.remove><CODE>os.remove (filename)</CODE></A></H3>
<P>Deletes the file or directory with the given name. Directories must =
be empty=20
to be removed. If this function fails, it returns <B>nil</B>, plus a =
string=20
describing the error.=20
<P>
<HR>

<H3><A name=3Dpdf-os.rename><CODE>os.rename (oldname, =
newname)</CODE></A></H3>
<P>Renames file or directory named <CODE>oldname</CODE> to =
<CODE>newname</CODE>.=20
If this function fails, it returns <B>nil</B>, plus a string describing =
the=20
error.=20
<P>
<HR>

<H3><A name=3Dpdf-os.setlocale><CODE>os.setlocale (locale [,=20
category])</CODE></A></H3>
<P>Sets the current locale of the program. <CODE>locale</CODE> is a =
string=20
specifying a locale; <CODE>category</CODE> is an optional string =
describing=20
which category to change: <CODE>"all"</CODE>, <CODE>"collate"</CODE>,=20
<CODE>"ctype"</CODE>, <CODE>"monetary"</CODE>, <CODE>"numeric"</CODE>, =
or=20
<CODE>"time"</CODE>; the default category is <CODE>"all"</CODE>. The =
function=20
returns the name of the new locale, or <B>nil</B> if the request cannot =
be=20
honored.=20
<P>If <CODE>locale</CODE> is the empty string, the current locale is set =
to an=20
implementation-defined native locale. If <CODE>locale</CODE> is the =
string=20
"<CODE>C</CODE>", the current locale is set to the standard C locale.=20
<P>When called with <B>nil</B> as the first argument, this function only =
returns=20
the name of the current locale for the given category.=20
<P>
<HR>

<H3><A name=3Dpdf-os.time><CODE>os.time ([table])</CODE></A></H3>
<P>Returns the current time when called without arguments, or a time=20
representing the date and time specified by the given table. This table =
must=20
have fields <CODE>year</CODE>, <CODE>month</CODE>, and <CODE>day</CODE>, =
and may=20
have fields <CODE>hour</CODE>, <CODE>min</CODE>, <CODE>sec</CODE>, and=20
<CODE>isdst</CODE> (for a description of these fields, see the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-os.date"><CODE>os.d=
ate</CODE></A>=20
function).=20
<P>The returned value is a number, whose meaning depends on your system. =
In=20
POSIX, Windows, and some other systems, this number counts the number of =
seconds=20
since some given start time (the "epoch"). In other systems, the meaning =
is not=20
specified, and the number returned by <CODE>time</CODE> can be used only =
as an=20
argument to <CODE>date</CODE> and <CODE>difftime</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-os.tmpname><CODE>os.tmpname ()</CODE></A></H3>
<P>Returns a string with a file name that can be used for a temporary =
file. The=20
file must be explicitly opened before its use and explicitly removed =
when no=20
longer needed.=20
<P>On some systems (POSIX), this function also creates a file with that =
name, to=20
avoid security risks. (Someone else might create the file with wrong =
permissions=20
in the time between getting the name and creating the file.) You still =
have to=20
open the file to use it and to remove it (even if you do not use it).=20
<P>When possible, you may prefer to use <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-io.tmpfile"><CODE>i=
o.tmpfile</CODE></A>,=20
which automatically removes the file when the program ends.=20
<H2>5.9 - <A name=3D5.9>The Debug Library</A></H2>
<P>This library provides the functionality of the debug interface to Lua =

programs. You should exert care when using this library. The functions =
provided=20
here should be used exclusively for debugging and similar tasks, such as =

profiling. Please resist the temptation to use them as a usual =
programming tool:=20
they can be very slow. Moreover, several of these functions violate some =

assumptions about Lua code (e.g., that variables local to a function =
cannot be=20
accessed from outside or that userdata metatables cannot be changed by =
Lua code)=20
and therefore can compromise otherwise secure code.=20
<P>All functions in this library are provided inside the <A=20
name=3Dpdf-debug><CODE>debug</CODE></A> table. All functions that =
operate over a=20
thread have an optional first argument which is the thread to operate =
over. The=20
default is always the current thread.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.debug><CODE>debug.debug ()</CODE></A></H3>
<P>Enters an interactive mode with the user, running each string that =
the user=20
enters. Using simple commands and other debug facilities, the user can =
inspect=20
global and local variables, change their values, evaluate expressions, =
and so=20
on. A line containing only the word <CODE>cont</CODE> finishes this =
function, so=20
that the caller continues its execution.=20
<P>Note that commands for <CODE>debug.debug</CODE> are not lexically =
nested=20
within any function, and so have no direct access to local variables.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.getfenv><CODE>debug.getfenv =
(o)</CODE></A></H3>Returns the=20
environment of object <CODE>o</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.gethook><CODE>debug.gethook =
([thread])</CODE></A></H3>
<P>Returns the current hook settings of the thread, as three values: the =
current=20
hook function, the current hook mask, and the current hook count (as set =
by the=20
<A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-debug.sethook"><COD=
E>debug.sethook</CODE></A>=20
function).=20
<P>
<HR>

<H3><A name=3Dpdf-debug.getinfo><CODE>debug.getinfo ([thread,] function =
[,=20
what])</CODE></A></H3>
<P>Returns a table with information about a function. You can give the =
function=20
directly, or you can give a number as the value of =
<CODE>function</CODE>, which=20
means the function running at level <CODE>function</CODE> of the call =
stack of=20
the given thread: level&nbsp;0 is the current function =
(<CODE>getinfo</CODE>=20
itself); level&nbsp;1 is the function that called <CODE>getinfo</CODE>; =
and so=20
on. If <CODE>function</CODE> is a number larger than the number of =
active=20
functions, then <CODE>getinfo</CODE> returns <B>nil</B>.=20
<P>The returned table can contain all the fields returned by <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_getinfo"><CODE>lua_=
getinfo</CODE></A>,=20
with the string <CODE>what</CODE> describing which fields to fill in. =
The=20
default for <CODE>what</CODE> is to get all information available, =
except the=20
table of valid lines. If present, the option '<CODE>f</CODE>' adds a =
field named=20
<CODE>func</CODE> with the function itself. If present, the option=20
'<CODE>L</CODE>' adds a field named <CODE>activelines</CODE> with the =
table of=20
valid lines.=20
<P>For instance, the expression <CODE>debug.getinfo(1,"n").name</CODE> =
returns a=20
table with a name for the current function, if a reasonable name can be =
found,=20
and the expression <CODE>debug.getinfo(print)</CODE> returns a table =
with all=20
available information about the <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-print"><CODE>print<=
/CODE></A>=20
function.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.getlocal><CODE>debug.getlocal ([thread,] level,=20
local)</CODE></A></H3>
<P>This function returns the name and the value of the local variable =
with index=20
<CODE>local</CODE> of the function at level <CODE>level</CODE> of the =
stack.=20
(The first parameter or local variable has index&nbsp;1, and so on, =
until the=20
last active local variable.) The function returns <B>nil</B> if there is =
no=20
local variable with the given index, and raises an error when called =
with a=20
<CODE>level</CODE> out of range. (You can call <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-debug.getinfo"><COD=
E>debug.getinfo</CODE></A>=20
to check whether the level is valid.)=20
<P>Variable names starting with '<CODE>(</CODE>' (open parentheses) =
represent=20
internal variables (loop control variables, temporaries, and =
C&nbsp;function=20
locals).=20
<P>
<HR>

<H3><A name=3Dpdf-debug.getmetatable><CODE>debug.getmetatable=20
(object)</CODE></A></H3>
<P>Returns the metatable of the given <CODE>object</CODE> or <B>nil</B> =
if it=20
does not have a metatable.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.getregistry><CODE>debug.getregistry =
()</CODE></A></H3>
<P>Returns the registry table (see <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#3.5">=A73.5</A>).=20
<P>
<HR>

<H3><A name=3Dpdf-debug.getupvalue><CODE>debug.getupvalue (func,=20
up)</CODE></A></H3>
<P>This function returns the name and the value of the upvalue with =
index=20
<CODE>up</CODE> of the function <CODE>func</CODE>. The function returns=20
<B>nil</B> if there is no upvalue with the given index.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.setfenv><CODE>debug.setfenv (object,=20
table)</CODE></A></H3>
<P>Sets the environment of the given <CODE>object</CODE> to the given=20
<CODE>table</CODE>. Returns <CODE>object</CODE>.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.sethook><CODE>debug.sethook ([thread,] hook, =
mask [,=20
count])</CODE></A></H3>
<P>Sets the given function as a hook. The string <CODE>mask</CODE> and =
the=20
number <CODE>count</CODE> describe when the hook will be called. The =
string mask=20
may have the following characters, with the given meaning:=20
<UL>
  <LI><B><CODE>"c"</CODE>:</B> the hook is called every time Lua calls a =

  function;=20
  <LI><B><CODE>"r"</CODE>:</B> the hook is called every time Lua returns =
from a=20
  function;=20
  <LI><B><CODE>"l"</CODE>:</B> the hook is called every time Lua enters =
a new=20
  line of code. </LI></UL>
<P>With a <CODE>count</CODE> different from zero, the hook is called =
after every=20
<CODE>count</CODE> instructions.=20
<P>When called without arguments, <A=20
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-debug.sethook"><COD=
E>debug.sethook</CODE></A>=20
turns off the hook.=20
<P>When the hook is called, its first parameter is a string describing =
the event=20
that has triggered its call: <CODE>"call"</CODE>, <CODE>"return"</CODE> =
(or=20
<CODE>"tail return"</CODE>, when simulating a return from a tail call),=20
<CODE>"line"</CODE>, and <CODE>"count"</CODE>. For line events, the hook =
also=20
gets the new line number as its second parameter. Inside a hook, you can =
call=20
<CODE>getinfo</CODE> with level&nbsp;2 to get more information about the =
running=20
function (level&nbsp;0 is the <CODE>getinfo</CODE> function, and =
level&nbsp;1 is=20
the hook function), unless the event is <CODE>"tail return"</CODE>. In =
this=20
case, Lua is only simulating the return, and a call to =
<CODE>getinfo</CODE> will=20
return invalid data.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.setlocal><CODE>debug.setlocal ([thread,] level, =
local,=20
value)</CODE></A></H3>
<P>This function assigns the value <CODE>value</CODE> to the local =
variable with=20
index <CODE>local</CODE> of the function at level <CODE>level</CODE> of =
the=20
stack. The function returns <B>nil</B> if there is no local variable =
with the=20
given index, and raises an error when called with a <CODE>level</CODE> =
out of=20
range. (You can call <CODE>getinfo</CODE> to check whether the level is =
valid.)=20
Otherwise, it returns the name of the local variable.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.setmetatable><CODE>debug.setmetatable (object,=20
table)</CODE></A></H3>
<P>Sets the metatable for the given <CODE>object</CODE> to the given=20
<CODE>table</CODE> (which can be <B>nil</B>).=20
<P>
<HR>

<H3><A name=3Dpdf-debug.setupvalue><CODE>debug.setupvalue (func, up,=20
value)</CODE></A></H3>
<P>This function assigns the value <CODE>value</CODE> to the upvalue =
with index=20
<CODE>up</CODE> of the function <CODE>func</CODE>. The function returns=20
<B>nil</B> if there is no upvalue with the given index. Otherwise, it =
returns=20
the name of the upvalue.=20
<P>
<HR>

<H3><A name=3Dpdf-debug.traceback><CODE>debug.traceback ([thread,] =
[message] [,=20
level])</CODE></A></H3>
<P>Returns a string with a traceback of the call stack. An optional=20
<CODE>message</CODE> string is appended at the beginning of the =
traceback. An=20
optional <CODE>level</CODE> number tells at which level to start the =
traceback=20
(default is 1, the function calling <CODE>traceback</CODE>).=20
<H1>6 - <A name=3D6>Lua Stand-alone</A></H1>
<P>Although Lua has been designed as an extension language, to be =
embedded in a=20
host C&nbsp;program, it is also frequently used as a stand-alone =
language. An=20
interpreter for Lua as a stand-alone language, called simply =
<CODE>lua</CODE>,=20
is provided with the standard distribution. The stand-alone interpreter =
includes=20
all standard libraries, including the debug library. Its usage is: <PRE> =
    lua [options] [script [args]]
</PRE>
<P>The options are:=20
<UL>
  <LI><B><CODE>-e <EM>stat</EM></CODE>:</B> executes string =
<EM>stat</EM>;=20
  <LI><B><CODE>-l <EM>mod</EM></CODE>:</B> "requires" <EM>mod</EM>;=20
  <LI><B><CODE>-i</CODE>:</B> enters interactive mode after running=20
  <EM>script</EM>;=20
  <LI><B><CODE>-v</CODE>:</B> prints version information;=20
  <LI><B><CODE>--</CODE>:</B> stops handling options;=20
  <LI><B><CODE>-</CODE>:</B> executes <CODE>stdin</CODE> as a file and =
stops=20
  handling options. </LI></UL>
<P>After handling its options, <CODE>lua</CODE> runs the given =
<EM>script</EM>,=20
passing to it the given <EM>args</EM> as string arguments. When called =
without=20
arguments, <CODE>lua</CODE> behaves as <CODE>lua -v -i</CODE> when the =
standard=20
input (<CODE>stdin</CODE>) is a terminal, and as <CODE>lua -</CODE> =
otherwise.=20
<P>Before running any argument, the interpreter checks for an =
environment=20
variable <A name=3Dpdf-LUA_INIT><CODE>LUA_INIT</CODE></A>. If its format =
is=20
<CODE>@<EM>filename</EM></CODE>, then <CODE>lua</CODE> executes the =
file.=20
Otherwise, <CODE>lua</CODE> executes the string itself.=20
<P>All options are handled in order, except <CODE>-i</CODE>. For =
instance, an=20
invocation like <PRE>     $ lua -e'a=3D1' -e 'print(a)' script.lua
</PRE>
<P>will first set <CODE>a</CODE> to 1, then print the value of =
<CODE>a</CODE>=20
(which is '<CODE>1</CODE>'), and finally run the file =
<CODE>script.lua</CODE>=20
with no arguments. (Here <CODE>$</CODE> is the shell prompt. Your prompt =
may be=20
different.)=20
<P>Before starting to run the script, <CODE>lua</CODE> collects all =
arguments in=20
the command line in a global table called <CODE>arg</CODE>. The script =
name is=20
stored at index 0, the first argument after the script name goes to =
index 1, and=20
so on. Any arguments before the script name (that is, the interpreter =
name plus=20
the options) go to negative indices. For instance, in the call <PRE>     =
$ lua -la b.lua t1 t2
</PRE>
<P>the interpreter first runs the file <CODE>a.lua</CODE>, then creates =
a table <PRE>     arg =3D { [-2] =3D "lua", [-1] =3D "-la",
             [0] =3D "b.lua",
             [1] =3D "t1", [2] =3D "t2" }
</PRE>
<P>and finally runs the file <CODE>b.lua</CODE>. The script is called =
with=20
<CODE>arg[1]</CODE>, <CODE>arg[2]</CODE>, =B7=B7=B7 as arguments; it can =
also access=20
these arguments with the vararg expression '<CODE>...</CODE>'.=20
<P>In interactive mode, if you write an incomplete statement, the =
interpreter=20
waits for its completion by issuing a different prompt.=20
<P>If the global variable <A name=3Dpdf-_PROMPT><CODE>_PROMPT</CODE></A> =
contains=20
a string, then its value is used as the prompt. Similarly, if the global =

variable <A name=3Dpdf-_PROMPT2><CODE>_PROMPT2</CODE></A> contains a =
string, its=20
value is used as the secondary prompt (issued during incomplete =
statements).=20
Therefore, both prompts can be changed directly on the command line or =
in any=20
Lua programs by assigning to <CODE>_PROMPT</CODE>. See the next example: =
<PRE>     $ lua -e"_PROMPT=3D'myprompt&gt; '" -i
</PRE>
<P>(The outer pair of quotes is for the shell, the inner pair is for =
Lua.) Note=20
the use of <CODE>-i</CODE> to enter interactive mode; otherwise, the =
program=20
would just end silently right after the assignment to =
<CODE>_PROMPT</CODE>.=20
<P>To allow the use of Lua as a script interpreter in Unix systems, the=20
stand-alone interpreter skips the first line of a chunk if it starts =
with=20
<CODE>#</CODE>. Therefore, Lua scripts can be made into executable =
programs by=20
using <CODE>chmod +x</CODE> and the&nbsp;<CODE>#!</CODE> form, as in =
<PRE>     #!/usr/local/bin/lua
</PRE>
<P>(Of course, the location of the Lua interpreter may be different in =
your=20
machine. If <CODE>lua</CODE> is in your <CODE>PATH</CODE>, then <PRE>    =
 #!/usr/bin/env lua
</PRE>
<P>is a more portable solution.)=20
<H1>7 - <A name=3D7>Incompatibilities with the Previous Version</A></H1>
<P>Here we list the incompatibilities that you may find when moving a =
program=20
from Lua&nbsp;5.0 to Lua&nbsp;5.1. You can avoid most of the =
incompatibilities=20
compiling Lua with appropriate options (see file =
<CODE>luaconf.h</CODE>).=20
However, all these compatibility options will be removed in the next =
version of=20
Lua.=20
<H2>7.1 - <A name=3D7.1>Changes in the Language</A></H2>
<UL>
  <LI>The vararg system changed from the pseudo-argument =
<CODE>arg</CODE> with a=20
  table with the extra arguments to the vararg expression. (See =
compile-time=20
  option <CODE>LUA_COMPAT_VARARG</CODE> in <CODE>luaconf.h</CODE>.)=20
  <LI>There was a subtle change in the scope of the implicit variables =
of the=20
  <B>for</B> statement and for the <B>repeat</B> statement.=20
  <LI>The long string/long comment syntax =
(<CODE>[[<EM>string</EM>]]</CODE>)=20
  does not allow nesting. You can use the new syntax=20
  (<CODE>[=3D[<EM>string</EM>]=3D]</CODE>) in these cases. (See =
compile-time option=20
  <CODE>LUA_COMPAT_LSTR</CODE> in <CODE>luaconf.h</CODE>.) </LI></UL>
<H2>7.2 - <A name=3D7.2>Changes in the Libraries</A></H2>
<UL>
  <LI>Function <CODE>string.gfind</CODE> was renamed <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-string.gmatch"><COD=
E>string.gmatch</CODE></A>.=20
  (See compile-time option <CODE>LUA_COMPAT_GFIND</CODE> in=20
  <CODE>luaconf.h</CODE>.)=20
  <LI>When <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-string.gsub"><CODE>=
string.gsub</CODE></A>=20
  is called with a function as its third argument, whenever this =
function=20
  returns <B>nil</B> or <B>false</B> the replacement string is the whole =
match,=20
  instead of the empty string.=20
  <LI>Function <CODE>table.setn</CODE> was deprecated. Function=20
  <CODE>table.getn</CODE> corresponds to the new length operator=20
  (<CODE>#</CODE>); use the operator instead of the function. (See =
compile-time=20
  option <CODE>LUA_COMPAT_GETN</CODE> in <CODE>luaconf.h</CODE>.)=20
  <LI>Function <CODE>loadlib</CODE> was renamed <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.loadlib"><C=
ODE>package.loadlib</CODE></A>.=20
  (See compile-time option <CODE>LUA_COMPAT_LOADLIB</CODE> in=20
  <CODE>luaconf.h</CODE>.)=20
  <LI>Function <CODE>math.mod</CODE> was renamed <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-math.fmod"><CODE>ma=
th.fmod</CODE></A>.=20
  (See compile-time option <CODE>LUA_COMPAT_MOD</CODE> in=20
  <CODE>luaconf.h</CODE>.)=20
  <LI>Functions <CODE>table.foreach</CODE> and =
<CODE>table.foreachi</CODE> are=20
  deprecated. You can use a for loop with <CODE>pairs</CODE> or=20
  <CODE>ipairs</CODE> instead.=20
  <LI>There were substantial changes in function <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-require"><CODE>requ=
ire</CODE></A>=20
  due to the new module system. However, the new behavior is mostly =
compatible=20
  with the old, but <CODE>require</CODE> gets the path from <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-package.path"><CODE=
>package.path</CODE></A>=20
  instead of from <CODE>LUA_PATH</CODE>.=20
  <LI>Function <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#pdf-collectgarbage"><CO=
DE>collectgarbage</CODE></A>=20
  has different arguments. Function <CODE>gcinfo</CODE> is deprecated; =
use=20
  <CODE>collectgarbage("count")</CODE> instead. </LI></UL>
<H2>7.3 - <A name=3D7.3>Changes in the API</A></H2>
<UL>
  <LI>The <CODE>luaopen_*</CODE> functions (to open libraries) cannot be =
called=20
  directly, like a regular C function. They must be called through Lua, =
like a=20
  Lua function.=20
  <LI>Function <CODE>lua_open</CODE> was replaced by <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_newstate"><CODE>lua=
_newstate</CODE></A>=20
  to allow the user to set a memory-allocation function. You can use <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_newstate"><CODE>lu=
aL_newstate</CODE></A>=20
  from the standard library to create a state with a standard allocation =

  function (based on <CODE>realloc</CODE>).=20
  <LI>Functions <CODE>luaL_getn</CODE> and <CODE>luaL_setn</CODE> (from =
the=20
  auxiliary library) are deprecated. Use <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#lua_objlen"><CODE>lua_o=
bjlen</CODE></A>=20
  instead of <CODE>luaL_getn</CODE> and nothing instead of=20
  <CODE>luaL_setn</CODE>.=20
  <LI>Function <CODE>luaL_openlib</CODE> was replaced by <A=20
  =
href=3D"http://www.lua.org/manual/5.1/manual.html#luaL_register"><CODE>lu=
aL_register</CODE></A>.=20

  <LI>Function <CODE>luaL_checkudata</CODE> now throws an error when the =
given=20
  value is not a userdata of the expected type. (In Lua&nbsp;5.0 it =
returned=20
  <CODE>NULL</CODE>.) </LI></UL>
<P>
<H1>8 - <A name=3D8>The Complete Syntax of Lua</A></H1>
<P>Here is the complete syntax of Lua in extended BNF. (It does not =
describe=20
operator precedences.) <PRE>
	chunk ::=3D {stat [`<B>;</B>=B4]} [laststat [`<B>;</B>=B4]]

	block ::=3D chunk

	stat ::=3D  varlist `<B>=3D</B>=B4 explist |=20
		 functioncall |=20
		 <B>do</B> block <B>end</B> |=20
		 <B>while</B> exp <B>do</B> block <B>end</B> |=20
		 <B>repeat</B> block <B>until</B> exp |=20
		 <B>if</B> exp <B>then</B> block {<B>elseif</B> exp <B>then</B> block} =
[<B>else</B> block] <B>end</B> |=20
		 <B>for</B> Name `<B>=3D</B>=B4 exp `<B>,</B>=B4 exp [`<B>,</B>=B4 =
exp] <B>do</B> block <B>end</B> |=20
		 <B>for</B> namelist <B>in</B> explist <B>do</B> block <B>end</B> |=20
		 <B>function</B> funcname funcbody |=20
		 <B>local</B> <B>function</B> Name funcbody |=20
		 <B>local</B> namelist [`<B>=3D</B>=B4 explist]=20

	laststat ::=3D <B>return</B> [explist] | <B>break</B>

	funcname ::=3D Name {`<B>.</B>=B4 Name} [`<B>:</B>=B4 Name]

	varlist ::=3D var {`<B>,</B>=B4 var}

	var ::=3D  Name | prefixexp `<B>[</B>=B4 exp `<B>]</B>=B4 | prefixexp =
`<B>.</B>=B4 Name=20

	namelist ::=3D Name {`<B>,</B>=B4 Name}

	explist ::=3D {exp `<B>,</B>=B4} exp

	exp ::=3D  <B>nil</B> | <B>false</B> | <B>true</B> | Number | String | =
`<B>...</B>=B4 | function |=20
		 prefixexp | tableconstructor | exp binop exp | unop exp=20

	prefixexp ::=3D var | functioncall | `<B>(</B>=B4 exp `<B>)</B>=B4

	functioncall ::=3D  prefixexp args | prefixexp `<B>:</B>=B4 Name args=20

	args ::=3D  `<B>(</B>=B4 [explist] `<B>)</B>=B4 | tableconstructor | =
String=20

	function ::=3D <B>function</B> funcbody

	funcbody ::=3D `<B>(</B>=B4 [parlist] `<B>)</B>=B4 block <B>end</B>

	parlist ::=3D namelist [`<B>,</B>=B4 `<B>...</B>=B4] | `<B>...</B>=B4

	tableconstructor ::=3D `<B>{</B>=B4 [fieldlist] `<B>}</B>=B4

	fieldlist ::=3D field {fieldsep field} [fieldsep]

	field ::=3D `<B>[</B>=B4 exp `<B>]</B>=B4 `<B>=3D</B>=B4 exp | Name =
`<B>=3D</B>=B4 exp | exp

	fieldsep ::=3D `<B>,</B>=B4 | `<B>;</B>=B4

	binop ::=3D `<B>+</B>=B4 | `<B>-</B>=B4 | `<B>*</B>=B4 | `<B>/</B>=B4 | =
`<B>^</B>=B4 | `<B>%</B>=B4 | `<B>..</B>=B4 |=20
		 `<B>&lt;</B>=B4 | `<B>&lt;=3D</B>=B4 | `<B>&gt;</B>=B4 | =
`<B>&gt;=3D</B>=B4 | `<B>=3D=3D</B>=B4 | `<B>~=3D</B>=B4 |=20
		 <B>and</B> | <B>or</B>

	unop ::=3D `<B>-</B>=B4 | <B>not</B> | `<B>#</B>=B4

</PRE>
<P>
<HR>
<SMALL>Last update: Wed Sep 28 00:59:24 BRT 2011 </SMALL><!--=0A=
Last change: minor edit=0A=
--></BODY></HTML>

------=_NextPart_000_0000_01CC8A6B.70EB3BE0
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.lua.org/images/logo.gif

R0lGODdhgACAAPcAAAAAcgAAdgAAegAAfQcHfgkJf29vb3FxcXZ2dnp6en9/fwEBgAQEgQgIgwsL
hA4Ogg8PhQ4OhhERhRYWhxERiBUVihkZihoajB0dix0djSEhjiUljyIikCUlkSkpkiwskzU1lzEx
lTU1mTExmDo6mjo6nD8/nUJCn0REnkJCoEVFoUpKo0hIpExMo01NpVBQp1RUplFRqFdXq1lZqlpa
rFxcq15erWBgr2NjsWdnsWlps2pqs29vt2xstHFxt3Z2u3R0uXl5u3t7vX9/v35+vYKCgoWFhYiI
iI6OjpCQkJWVlZubm52dnYCAv6GhoaWlpampqa2trbOzs7e3t7m5ub29vYODwYeHwomJw4uLxY6O
xpCQx5KSyJWVypmZy5mZzJ+fz6Ghz6Ki0aWl0qmp06mp1K2t1q+v17Gx17Gx2LW12ru73by83cPD
w8fHx8rKyszMzMDA39LS0tXV1djY2N3d3cHB4MfH48fH5MnJ5MrK5c7O5tDQ59PT6dXV6tjY69ra
7N3d7uHh4eXl5eDg7+rq6u7u7uLi8Obm8+jo8+np9O7u9vHx8fDw9/X19fPz+ff3+/n5+fv7/f//
/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAgACAAAAI/gAnCRxI
sKDBgwgTKlzIsKHDhxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJE6Gk
m5Nw1rQYiVGhOoYIGhrEKFJKSTsbGh1IR4FTBFMIRkFQpMiRQR4RmSFyQwYOK2oaCUSatKAjOlOS
IFk6iREcQYUMsW37U04VRgMdMZlSZy7EPTIgCAhAmLCACjsClTXIBEESKXMuOpKCxCmViJB2DAgw
YAGDz58XbG5wpawjgoKCcmTUBg5ERCMCeB7Qmbbozgw2v4A0MxKcI0xURnmTUJGHALlFK69d23OA
FTLdGFEQBWvKKAmMuPE7qQXyBcvD/odnEMBHzpdQopxmyWgKgigFvSBvTv+2cuUC2CxOaUi1wEca
MBdec8vZJsAJKjkyhX87IRWGbAMOWF9td6BER1WF7DfJCwJEWJ+E5AlxHklSHBAFdzVFokGHHhYY
4YEmOaKEHBfppNBNZE1ESAO0TSjehwJokGNZQw4kySOIHBLIIYg8UuRYEfVhG4E+fjhABY8QSZAk
fpAhhAwkcFCBAw185kAFHJAggxBj+DHkkwj5MWGVHmIZUhWuSZTjIWDIEGBhAgjQ46CBDsZZBjKA
cchrPE4JHp0CCtDBnQYQN9EiYKTQAGG2hQaei+CFNoChDKTwhSJGKtQBiwJC+qkA/tB9RMUBND5E
lh87UBCAoJ525uKcyn02agAS6ODHjZPYMN99kNZGXmlwWkTHAZFF5IcMBHD2aI/bMithhI9yJkMf
CqHBqn10LkcAuR5FYt1DiuSQ7QAMfNosuHPiNuoAOSCSUAjntiggeTC8RNYXEnBWr6PpAuvqZhB0
ASVBZgiQHMMCF8AuS0gdooLCGD8ssIfObpaCYjkilcN8Di9HnhYdsYbiQUiZkfDCIufc4n2eCSBB
GSOOtcJ33Po6cAA7eASFAus1JISg9o6sc5VFFy3ADwZJIoPCj6I7WwBYdwTHAXU4pDXRIUuttoCe
gVavfeTFwFtBXSTcqaiDZXCG/keFIHBZQ4+cQPTahNPna26GAjobbeSZIFaqiljRwWaAMiBCF1l6
RIcTMxf0CAksFy56c4M5UEIORFzxgwwcbGY0eSIsQnMfY2RxhRZmKDbxSpCYsOzooosWQAdc+FuQ
JHrk0ECHuAVAQuap2vSSC8umPTXJohGQRco4EgRICkSTF2vWOEZ7ElI9DH59zp0JYAEeu2ct0A+y
MR6ADiwZUvZCSIER+vqEE80EjmW+LU2CCPVzjsQK+JEoHKEhe+BR1ABItW0NYA1BYwhSZgCh7Omh
IYLIE0YMkQARJkQSIGAe8ER2n/Jk0CGKsADpQjA3hbwBAQyqiBQeiCwEXmyF/tijUgVQpadJaKF+
9ApAEBpyBClgJBIKaAND9kCAQQHRRwMij3kYWJwKGG0BBPjgQtzANIwIomkJWcG5KBhE+wjADhXZ
4O8EoAKGOKIIJgyJubzGRisxqwKPmwhSuhC6BQgAaAuRS0lIwKIrCoxAhhSBRZDCBub5SgAgkEnF
HOkqF8EKI1KyV/vI8MKNREIOaEQICizJyTa2b3wVCaVtwCMAE4hEEAh4F0L00KpW+tFAkozjJOyg
wlkKoEILeUOGJEIFHiokfQvrWh+/RZ8LQK+I/vthEnNQSoIU4W8RUQJ8FPIIDBjOlz9C1wCQWRFl
5YZKFpCdQqSgBIk4AgG1/kpIGiz5xWme83VK7CbgzDnB9plhIXIoI0R8gxfprSw5fEQnqAaQAXlG
BClfgBDDyHMDgbYFAXTwiCQ8UExpYnF9PgpAEzyakEdsoKS+MmQHGDiHhnJESgyjEjWDZ6UwsvR4
k9BBAv85gD0cZRJgWKNJ8TU6PwZpUVw8DxdgyizyeOGnHEGKULWp03/y9FeG3AAg4gdUI1KVOdvE
6kMMgYQcGsQErDSa4Xo5ta7iRwJi2FL5BqKIGTTypIYkAUM6dxA6JMCmB4FEBmLKNkNeARF/0AME
ivZV6wWgBGaoIUECQYSE3aaCorGAZg3iCCSE1CFwMAJhD9EoRwUrAGAQ/sgiKNDPwtl1lgwIlAVi
QIQvgGELPSgBeVjYIwboLiFFsFRDquDMXXLrV+SJ7SRmy0awytVohQEUvdZGOnYiBAlVeEgbgqOQ
NSi1OdGVLW2lKTXA0jVUbnvb9QyphoU8ZqEnnEQZhppF2Kp3vi2rLVr7SJ68mg8K4KzRJB4UTcOl
d7rrDWBEeTZBF8VXvmojzxfUihGMVq+/0qWubUM24LQZMruGsaDAyLPAknj4nRF6sIjXBgEKUKC1
A4qAjd8ZqQF84AZW2AIXmmCDVZ11PAFocUaGkl8xfJg+Ml5vJwWABt7Qr8G30UOWaKA+AbhAjMez
gwiO7Cz/RrUhUUjC/kI2Sc0oC/hF+jngk0XzB4Hc4Du0xAJDXPDXbwUAaOarwzIbQgU1KyQOVH1t
iKX8SEPG2YcROlaylhUAG5xHEmoYAg+A0AWUTeIQkx2ZADCoECQ40SFtaO5BcNpm/0L4vfXJj0Ag
bbg6T+LOPDbqdH2X3QFw4TwxQCLJdJ0QJEgRtQkgrCJC7Vr7LZqFspazNulsZ6JxgCw6AEB8B1AA
3QlhzkaDgPEQEgkj5FEhhZACYSexqoKKxs3s9VG0aV2gsd76OwIQASQWkYgAfZZe81ZfeARwbYUY
AgH72wifvabo/6rN0bMGt61xzTgbS2CWbVtAAOAobWDRcSEKQqyC/r8N4y/CW20Bx3JnJl694tIm
cXQkC72hDDYOZwQp+2z1sx+e8gnZG9ddO/GVRvACHnDBDkhBig+xKICDqoS1lL3NyV2VcgmxHMaC
YoEY+mBRAw5B4EZrwHE3MogTLQSuS03izqf8aIkLBAd4DpJ3B7KIPViBDxGfdvsE6xFBHECXQG3C
hxv+6ojGuu1YFo293RlaTy/CDD94wQi8CADEgyig5iuEE0TeEO0sZA85fberRcx2gQieqw1Y1L3r
leRJGGULEjAU1AYQ56/rXTR5GKMC1n0QJ5BXISmE7ugZXSC0QnwSpx+QBuZGcbELRAwAwM2njj9z
/ISAIb6fyBuM/oCsI0aT8DOevvhfFefTozcAMzgPrglOFj7jzEC57ziS9Wy+SBTBDRNxhFsNgoiL
t0rGsTcoAmhF0TYGLHNJ+oEU6zcpAqFGMOYcmYQUVnCAn/UAhLAQg2AEg/YRWyVXMsYBNWZjIjiC
FAABtOR0LtVBAwAAYaOA8yEBRNQFAEAA2xIAHuBpCOQAX6RxHWVHI9EHVVQ06YUUi1CERniERRgJ
dpBE5mEUfiAC+1IBvwYJugN0ApAG5/EDPCIoFxAE8oQUBhhXtEFsLeGCGJZbsXVmsiQBUCUQfrAG
d5A5V0AEAsF4AsB3SJEIdsAGe5A5dwBokxAHVvA24BEANVAS/oWgXAnxB40idWbmEKyWb0RkEDKo
Z6vXPjYQLWMwACiwWTy2AA2wMSIxBwewgfITBE/2ASpwAinQiq74iq6oAlCIHxaQBYDAG5KACGqg
AoLSASqgAjLUNQLwAYoCCZIACYQwBiUgKANABJnDBp9CHmGDblPAewyBBONETi8lSoXSjd74jQyD
HBngAR0gGKwSKBgzGA2gAR/AAZtiMbQkAR+gAVinAV2HEFJQBBnxBofFEDnnWtEYKgIpfsb3TujY
LaL0I4VyXaKBjr4SAE6nEIygAIpoEUdwbAvRgV4FQBVGWb00fR9iL+TBTQwhBaqlEYrEEJAAMOxV
fE1lPelk/kUk0z4fcE0JkQQYiRJ+8ABy1Uq25S0mJhoPQC5cFAnW2BE4N3u+pDNgJTCHZHMrMUho
85PV1TKf9TJQ6RFLgH/8MwlXMJXEdUXu1SkqhVUpKSsJsH9ANYEY9jDT1EahEgB0yEUTmU8fkQRL
0BBIoQVQE0B95F4NmQVqtQRIMBJ9k5P5VQYEYDEwCWuV5ZK5RQBjoFZVkEskQQeAl196oAFgx1QU
hEXOkQEVElUTyZU0QYTB1pMBBjwSUhsB4AKocmaTUAhHyRIIo4KeuUL1wXoQsGEaIhBnZDaTgAgy
ECgIuZpheUkCEANt+JtG4AS2IhBxsIwdwmO/9JP1Eigi/hBnEEEFmXkSg4AAUDARaUCd22VFU9KY
jpIbu4JZExEFf+cSgpAATwAROWIHNAABuyJ9HdkieBMAEEADHCcRUIAAggATdXBqFKEIYKACgrGf
uBEa9TKhojIsAgABKvAF4yYR7nGgv9mVAqEIZgAEJeBFibMrgZJdgkIBJQAEZjCJslkQhfCdH0oz
ntMHZqAFP4ADMeACLMACL3ADP4A7fVhWNfoQUYCYFyVIMVoQNEoTbXAAT1CbN6ITZNE9T/QECsB5
OyEI05FwZXEhRgCm+xEJUFAtZYFLZnekv+kubHoQcGCaLREJavmmA9EGCGAEb0ClpgQHRVBPdiqR
UpAAeoaGElVQBAogBXUaqAPBCKeFElNABanEqA4hBUngBk8qEYVQBeFFqRhBB09gBAlwBFz6EJEQ
qgpQBArqqRgxCHs6EIOABEwQBVOAppNQB1VABVGwBB7qelLQBpnKqiM0BVDABEeQYIeKl04QrMLa
rM76rNAardLqEQEBADs=

------=_NextPart_000_0000_01CC8A6B.70EB3BE0
Content-Type: text/css;
	charset="koi8-r"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.lua.org/lua.css

BODY {
	TEXT-ALIGN: justify; BACKGROUND-COLOR: #ffffff; FONT-FAMILY: Helvetica, =
Arial, sans-serif; COLOR: #000000; MARGIN-LEFT: 20px; MARGIN-RIGHT: 20px
}
H1 {
	FONT-STYLE: italic; FONT-FAMILY: Verdana, Geneva, sans-serif; =
FONT-WEIGHT: normal
}
H2 {
	FONT-STYLE: italic; FONT-FAMILY: Verdana, Geneva, sans-serif; =
FONT-WEIGHT: normal
}
H3 {
	FONT-STYLE: italic; FONT-FAMILY: Verdana, Geneva, sans-serif; =
FONT-WEIGHT: normal
}
H4 {
	FONT-STYLE: italic; FONT-FAMILY: Verdana, Geneva, sans-serif; =
FONT-WEIGHT: normal
}
H2 {
	PADDING-BOTTOM: 0.4em; BACKGROUND-COLOR: #e0e0ff; PADDING-LEFT: 20px; =
PADDING-RIGHT: 20px; MARGIN-LEFT: -20px; PADDING-TOP: 0.4em
}
H3 {
	BORDER-LEFT: #e0e0ff 1em solid; PADDING-LEFT: 0.5em
}
TABLE H3 {
	BORDER-LEFT: medium none; PADDING-LEFT: 0px
}
A:link {
	COLOR: #000080; TEXT-DECORATION: none
}
A:visited {
	TEXT-DECORATION: none
}
A:hover:link {
	BACKGROUND-COLOR: #e0e0ff; COLOR: #000080
}
A:hover:visited {
	BACKGROUND-COLOR: #e0e0ff; COLOR: #000080
}
A:active {
	COLOR: #ff0000
}
A:active {
	COLOR: #ff0000
}
HR {
	BORDER-BOTTOM: 0px; BORDER-LEFT: 0px; BACKGROUND-COLOR: #a0a0a0; =
HEIGHT: 1px; COLOR: #a0a0a0; BORDER-TOP: 0px; BORDER-RIGHT: 0px
}
:unknown {
	BORDER-BOTTOM: #a0a0a0 2px solid; BORDER-LEFT: #a0a0a0 2px solid; =
PADDING-BOTTOM: 8px; BACKGROUND-COLOR: #f8f8f8; PADDING-LEFT: 8px; =
PADDING-RIGHT: 8px; BORDER-TOP: #a0a0a0 2px solid; BORDER-RIGHT: #a0a0a0 =
2px solid; PADDING-TOP: 8px
}
.footer {
	COLOR: gray; FONT-SIZE: small
}
INPUT[type=3Dtext] {
	BACKGROUND-IMAGE: url(images/search.png); BORDER-BOTTOM: #a0a0a0 2px =
solid; BORDER-LEFT: #a0a0a0 2px solid; PADDING-LEFT: 20px; =
BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: 4px center; HEIGHT: =
2em; BORDER-TOP: #a0a0a0 2px solid; BORDER-RIGHT: #a0a0a0 2px solid; =
border-radius: 2em; -moz-border-radius: 2em
}

------=_NextPart_000_0000_01CC8A6B.70EB3BE0
Content-Type: text/css;
	charset="koi8-r"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.lua.org/manual/manual.css

H3 CODE {
	FONT-FAMILY: inherit
}
PRE {
	FONT-SIZE: 105%
}
SPAN.apii {
	FONT-FAMILY: inherit; FLOAT: right
}
P + H1 {
	PADDING-BOTTOM: 0.4em; BACKGROUND-COLOR: #e0e0ff; PADDING-LEFT: 20px; =
MARGIN-LEFT: -20px; PADDING-TOP: 0.4em
}
UL + H1 {
	PADDING-BOTTOM: 0.4em; BACKGROUND-COLOR: #e0e0ff; PADDING-LEFT: 20px; =
MARGIN-LEFT: -20px; PADDING-TOP: 0.4em
}

------=_NextPart_000_0000_01CC8A6B.70EB3BE0--
